[{"id":"ce97a94626317b127a6da02030ff4c21","title":"shell","content":"SHELL 脚本基础操作和命令\n\n\n\nSHELL命令变量\n只读变量\n\n\n\n\n\n\n\n\n\n\nreadonly variable_name\n\n删除变量\n\n\n\n\n\n\n\n\n\n\nunset variable_name  \n\n传递参数\n\n\n$#\n传递到脚本的参数个数\n\n\n\n$*\n以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。\n\n\n$$\n脚本运行的当前进程ID号\n\n\n$!\n后台运行的最后一个进程的ID号\n\n\n$@\n与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。\n\n\n$-\n显示Shell使用的当前选项，与set命令功能相同。\n\n\n$?\n显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n\n\n运算符算数运算符\n\n\n运算符\n说明\n举例\n\n\n\n+\n加法\nexpr $a + $b 结果为 30。\n\n\n-\n减法\nexpr $a - $b 结果为 -10。\n\n\n*\n乘法\nexpr $a \\* $b 结果为  200。\n\n\n&#x2F;\n除法\nexpr $b / $a 结果为 2。\n\n\n%\n取余\nexpr $b % $a 结果为 0。\n\n\n&#x3D;\n赋值\na&#x3D;$b 把变量 b 的值赋给 a。\n\n\n&#x3D;&#x3D;\n相等。用于比较两个数字，相同则返回 true。\n[ $a &#x3D;&#x3D; $b ] 返回 false。\n\n\n!&#x3D;\n不相等。用于比较两个数字，不相同则返回 true。\n[ $a !&#x3D; $b ] 返回 true。\n\n\n\n关系运算符\n\n\n运算符\n说明\n举例\n\n\n\n-eq\n检测两个数是否相等，相等返回 true。\n[ $a -eq $b ] 返回 false。\n\n\n-ne\n检测两个数是否不相等，不相等返回 true。\n[ $a -ne $b ] 返回 true。\n\n\n-gt\n检测左边的数是否大于右边的，如果是，则返回 true。\n[ $a -gt $b ] 返回 false。\n\n\n-lt\n检测左边的数是否小于右边的，如果是，则返回 true。\n[ $a -lt $b ] 返回 true。\n\n\n-ge\n检测左边的数是否大于等于右边的，如果是，则返回 true。\n[ $a -ge $b ] 返回 false。\n\n\n-le\n检测左边的数是否小于等于右边的，如果是，则返回 true。\n[ $a -le $b ] 返回 true。\n\n\n\n布尔运算符\n\n\n运算符\n说明\n举例\n\n\n\n!\n非运算，表达式为 true 则返回 false，否则返回 true。\n[ ! false ] 返回 true。\n\n\n-o\n或运算，有一个表达式为 true 则返回 true。\n[ $a -lt 20 -o $b -gt 100 ] 返回 true。\n\n\n-a\n与运算，两个表达式都为 true 才返回 true。\n[ $a -lt 20 -a $b -gt 100 ] 返回 false。\n\n\n\n字符串运算符\n\n\n运算符\n说明\n举例\n\n\n\n&#x3D;\n检测两个字符串是否相等，相等返回 true。\n[ $a &#x3D; $b ] 返回 false。\n\n\n!&#x3D;\n检测两个字符串是否不相等，不相等返回 true。\n[ $a !&#x3D; $b ] 返回 true。\n\n\n-z\n检测字符串长度是否为0，为0返回 true。\n[ -z $a ] 返回 false。\n\n\n-n\n检测字符串长度是否不为 0，不为 0 返回 true。\n[ -n “$a” ] 返回 true。\n\n\n$\n检测字符串是否不为空，不为空返回 true。\n[ $a ] 返回 true。\n\n\n文件测试运算符\n\n\n操作符\n说明\n举例\n\n\n\n-b file\n检测文件是否是块设备文件，如果是，则返回 true。\n[ -b $file ] 返回 false。\n\n\n-c file\n检测文件是否是字符设备文件，如果是，则返回 true。\n[ -c $file ] 返回 false。\n\n\n-d file\n检测文件是否是目录，如果是，则返回 true。\n[ -d $file ] 返回 false。\n\n\n-f file\n检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。\n[ -f $file ] 返回 true。\n\n\n-g file\n检测文件是否设置了 SGID 位，如果是，则返回 true。\n[ -g $file ] 返回 false。\n\n\n-k file\n检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。\n[ -k $file ] 返回 false。\n\n\n-p file\n检测文件是否是有名管道，如果是，则返回 true。\n[ -p $file ] 返回 false。\n\n\n-u file\n检测文件是否设置了 SUID 位，如果是，则返回 true。\n[ -u $file ] 返回 false。\n\n\n-r file\n检测文件是否可读，如果是，则返回 true。\n[ -r $file ] 返回 true。\n\n\n-w file\n检测文件是否可写，如果是，则返回 true。\n[ -w $file ] 返回 true。\n\n\n-x file\n检测文件是否可执行，如果是，则返回 true。\n[ -x $file ] 返回 true。\n\n\n-s file\n检测文件是否为空（文件大小是否大于0），不为空返回 true。\n[ -s $file ] 返回 true。\n\n\n-e file\n检测文件（包括目录）是否存在，如果是，则返回 true。\n[ -e $file ] 返回 true。\n\n\n\n其他检查符：\n\n-S: 判断某文件是否 socket。\n-L: 检测文件是否存在并且是一个符号链接。\n\n\n\n流程控制if elseifif condition\nthen\n    command1 \n    command2\n    ...\n    commandN \nfi\n\nif elseif condition\nthen\n    command1 \n    command2\n    ...\n    commandN\nelse\n    command\nfi\n\nif else-if elseif condition1\nthen\n    command1\nelif condition2 \nthen \n    command2\nelse\n    commandN\nfi\n\n例子\na&#x3D;10\nb&#x3D;20\nif [ $a &#x3D;&#x3D; $b ]\nthen\n   echo &quot;a 等于 b&quot;\nelif [ $a -gt $b ]\nthen\n   echo &quot;a 大于 b&quot;\nelif [ $a -lt $b ]\nthen\n   echo &quot;a 小于 b&quot;\nelse\n   echo &quot;没有符合的条件&quot;\nfi\n\nfor 循环for var in item1 item2 ... itemN\ndo\n    command1\n    command2\n    ...\n    commandN\ndone\n\n例子\nfor loop in 1 2 3 4 5\ndo\n    echo &quot;The value is: $loop&quot;\ndone\n\nwhile 语句 (状态码为1执行【循环执行一系列命令直至条件为 false 时停止】)while condition\ndo\n    command\ndone\n\n\n例子\n#!&#x2F;bin&#x2F;bash\n\necho &#39;按下 &lt;CTRL-D&gt; 退出&#39;\necho -n &#39;输入你最喜欢的网站名: &#39;\nwhile read FILM\ndo\n    echo &quot;是的！$FILM 是一个好网站&quot;\ndone\n\nuntil 循环(状态码为0执行【循环执行一系列命令直至条件为 true 时停止】)until condition\ndo\n    command\ndone\n\n例子\n#!&#x2F;bin&#x2F;bash\n\na&#x3D;0\n\nuntil [ ! $a -lt 10 ]\ndo\n   echo $a\n   a&#x3D;&#96;expr $a + 1&#96;\ndone\n\ncase … esaccase 值 in\n模式1)\n    command1\n    command2\n    ...\n    commandN\n    ;;\n模式2)\n    command1\n    command2\n    ...\n    commandN\n    ;;\nesac\n\n例子\necho &#39;输入 1 到 4 之间的数字:&#39;\necho &#39;你输入的数字为:&#39;\nread aNum\ncase $aNum in\n    1)  echo &#39;你选择了 1&#39;\n    ;;\n    2)  echo &#39;你选择了 2&#39;\n    ;;\n    3)  echo &#39;你选择了 3&#39;\n    ;;\n    4)  echo &#39;你选择了 4&#39;\n    ;;\n    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;\n    ;;\nesac\n\n跳出循环break例子\n#!&#x2F;bin&#x2F;bash\nwhile :\ndo\n    echo -n &quot;输入 1 到 5 之间的数字:&quot;\n    read aNum\n    case $aNum in\n        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;\n        ;;\n        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;\n            break\n        ;;\n    esac\ndone\n\ncontinue例子\n#!&#x2F;bin&#x2F;bash\nwhile :\ndo\n    echo -n &quot;输入 1 到 5 之间的数字: &quot;\n    read aNum\n    case $aNum in\n        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;\n        ;;\n        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;\n            continue\n            echo &quot;游戏结束&quot;\n        ;;\n    esac\ndone\n\n\nShell函数[ function ] funname [()]\n\n&#123;\n\n    action;\n\n    [return int;]\n\n&#125;\n\n例子\n#!&#x2F;bin&#x2F;bash\n\nfunWithReturn()&#123;\n    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;\n    echo &quot;输入第一个数字: &quot;\n    read aNum\n    echo &quot;输入第二个数字: &quot;\n    read anotherNum\n    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;\n    return $(($aNum+$anotherNum))\n&#125;\nfunWithReturn\necho &quot;输入的两个数字之和为 $? !&quot;\n\n","slug":"shell","date":"2022-06-16T05:41:52.000Z","categories_index":"shell","tags_index":"脚本,linux","author_index":"云の博客"},{"id":"1a3dadd6d2dc049cf44f32d36e769289","title":"DOCLever","content":"搭建 DOCLever文档服务\n\n\n\n\n\n\n\n\n\n\n\n\nDOClever是一个可视化免费开源的接口管理工具 ,可以分析接口结构，校验接口正确性， 围绕接口定义文档，通过一系列自动化工具提升我们的协作效率。DOClever前后端全部采用了javascript来作为我们的开发语言，前端用的是vue+element UI，后端是express+mongodb，这样的框架集成了高并发，迭代快的特点，保证系统的稳定可靠。\n安装配置\n\n\n\n\n\n\n\n\n安装mongodb \n​\t\t官网下载：https://www.mongodb.com/download-center/community\n​\t\t64位下载库：http://dl.mongodb.org/dl/win32/x86_64\n​\t\t32位下载库：http://dl.mongodb.org/dl/win32/i386\n安装node \n​\t\t官网下载:  https://nodejs.org\n\n下载源码\n启动服务\n\n\n\n\n\n\n\n\n\n\n相关手册链接：https://www.kancloud.cn/lovefeiyang/doclever/432894                                             http://doclever.cn/controller/read/read.html#5a532f98b7731a2ba86093b3\n","slug":"doclever","date":"2020-10-20T02:59:39.000Z","categories_index":"nodeJs","tags_index":"服务,mongodb","author_index":"云の博客"},{"id":"58ea37fede9aed6ff7e0b612983be198","title":"批处理使用命令","content":"批处理使用命令\n\n\n\n批处理命令简介\necho\nrem\npause\ncall\nstart\ngoto\nset\n\n\n\n批处理常用命令总结\n批处理符号简介\n回显屏蔽 @\n重定向1 &gt;与&gt;&gt;\n重定向2 &lt;\n管道符号 |\n转义符 ^\n逻辑命令符包括：&amp;、&amp;&amp;、||\n\n\n\n批处理常用命令总结\n常用DOS命令文件夹管理\n\ncd 显示当前目录名或改变当前目录。\nmd 创建目录。\nrd 删除一个目录。\ndir 显示目录中的文件和子目录列表。\ntree 以图形显示驱动器或路径的文件夹结构。\npath 为可执行文件显示或设置一个搜索路径。\nxcopy 复制文件和目录树。\n\n文件管理\n\ntype 显示文本文件的内容。\ncopy 将一份或多份文件复制到另一个位置。\ndel 删除一个或数个文件。\nmove 移动文件并重命名文件和目录。(Windows XP Home Edition中没有)\nren 重命名文件。\nreplace 替换文件。\nattrib 显示或更改文件属性。\nfind 搜索字符串。\nfc 比较两个文件或两个文件集并显示它们之间的不同\n\n网络命令\n\nping 进行网络连接测试、名称解析\nftp 文件传输\nnet 网络命令集及用户管理\ntelnet 远程登陆\nipconfig显示、修改TCP&#x2F;IP设置\nmsg 给用户发送消息\narp 显示、修改局域网的IP地址-物理地址映射列表\n\n系统管理\n\nat 安排在特定日期和时间运行命令和程序\nshutdown立即或定时关机或重启\ntskill 结束进程\ntaskkill结束进程(比tskill高级，但WinXPHome版中无该命令)\ntasklist显示进程列表(Windows XP Home Edition中没有)\nsc 系统服务设置与控制\nreg 注册表控制台工具\npowercfg控制系统上的电源设置\n\n\n\n\n\n\n\n\n\n\n对于以上列出的所有命令，在cmd中输入命令+&#x2F;?即可查看该命令的帮助信息。如find &#x2F;?\nWindows Batch 常用命令 1 echo 和 @\n回显命令\n@                     #关闭单行回显\necho off              #从下一行开始关闭回显\n@echo off             #从本行开始关闭回显。一般批处理第一行都是这个\necho on               #从下一行开始打开回显\necho                  #显示当前是 echo off 状态还是 echo on 状态\necho.                 #输出一个”回车换行”，空白行\n                          #(同echo, echo; echo+ echo[ echo] echo&#x2F; echo)\n\n2 errorlevel\necho %errorlevel%\n每个命令运行结束，可以用这个命令行格式查看返回码\n默认值为0，一般命令执行出错会设 errorlevel 为1\n\n3 dir\n显示文件夹内容\ndir                  #显示当前目录中的文件和子目录\ndir &#x2F;a               #显示当前目录中的文件和子目录，包括隐藏文件和系统文件\ndir c: &#x2F;a:d          #显示 C 盘当前目录中的目录\ndir c: &#x2F;a:-d         #显示 C 盘根目录中的文件\ndir c: &#x2F;b&#x2F;p         #&#x2F;b只显示文件名，&#x2F;p分页显示\ndir *.exe &#x2F;s         #显示当前目录和子目录里所有的.exe文件\n\n4 cd\n切换目录\ncd                  #进入根目录\ncd                   #显示当前目录\ncd &#x2F;d d:sdk         #可以同时更改盘符和目录\n\n5 md\n创建目录\nmd d:abc          #如果 d:a 不存在，将会自动创建中级目录\n #如果命令扩展名被停用，则需要键入 mkdir abc。\n\n6 rd\n删除目录\nrd abc               #删除当前目录里的 abc 子目录，要求为空目录\nrd &#x2F;s&#x2F;q d:temp      #删除 d:temp 文件夹及其子文件夹和文件，&#x2F;q安静模式\n\n7 del\n删除文件\ndel d:test.txt      #删除指定文件，不能是隐藏、系统、只读文件\ndel &#x2F;q&#x2F;a&#x2F;f d:temp*.*\n删除 d:temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录\ndel &#x2F;q&#x2F;a&#x2F;f&#x2F;s d:temp*.*\n删除 d:temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录\n\n8 ren\n重命名命令\nren d:temp tmp      #支持对文件夹的重命名\n\n9 cls\n清屏\n\n10 type\n显示文件内容\ntype c:boot.ini     #显示指定文件的内容，程序文件一般会显示乱码\ntype *.txt           #显示当前目录里所有.txt文件的内容\n\n11 copy\n拷贝文件\ncopy c:test.txt d:test.bak\n复制 c:test.txt 文件到 d: ，并重命名为 test.bak\ncopy con test.txt\n从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件\ncon代表屏幕，prn代表打印机，nul代表空设备\ncopy 1.txt + 2.txt 3.txt\n合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件\n如果不指定 3.txt ，则保存到 1.txt\ncopy test.txt +\n复制文件到自己，实际上是修改了文件日期\n\n12 title\n设置cmd窗口的标题\ntitle 新标题         #可以看到cmd窗口的标题栏变了\n\n13 ver\n显示系统版本\n\n14 label 和 vol\n设置卷标\nvol                  #显示卷标\nlabel                #显示卷标，同时提示输入新卷标\nlabel c:system       #设置C盘的卷标为 system\n\n15 pause\n暂停命令\n\n16 rem 和 ::\n注释命令\n注释行不执行操作\n\n17 date 和 time\n日期和时间\ndate           #显示当前日期，并提示输入新日期，按&quot;回车&quot;略过输入\ndate&#x2F;t         #只显示当前日期，不提示输入新日期\ntime           #显示当前时间，并提示输入新时间，按&quot;回车&quot;略过输入\ntime&#x2F;t         #只显示当前时间，不提示输入新时间\n\n18 goto 和 :\n跳转命令\n:label         #行首为:表示该行是标签行，标签行不执行操作\ngoto label     #跳转到指定的标签那一行\n\n19 find (外部命令)\n查找命令\nfind &quot;abc&quot; c:test.txt\n在 c:test.txt 文件里查找含 abc 字符串的行\n如果找不到，将设 errorlevel 返回码为1\nfind &#x2F;i “abc” c:test.txt\n查找含 abc 的行，忽略大小写\nfind &#x2F;c &quot;abc&quot; c:test.txt\n显示含 abc 的行的行数\n\n20 more (外部命令)\n逐屏显示\nmore c:test.txt     #逐屏显示 c:test.txt 的文件内容\n\n21 tree\n显示目录结构\ntree d:             #显示D盘的文件目录结构\n\n22 &amp;\n顺序执行多条命令，而不管命令是否执行成功\n\n23 &amp;&amp;\n顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令\nfind &quot;ok&quot; c:test.txt &amp;&amp; echo 成功\n如果找到了&quot;ok&quot;字样，就显示&quot;成功&quot;，找不到就不显示\n\n24 ||\n顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令\nfind &quot;ok&quot; c:test.txt || echo 不成功\n如果找不到&quot;ok&quot;字样，就显示&quot;不成功&quot;，找到了就不显示\n\n25 |\n管道命令\ndir *.* &#x2F;s&#x2F;a | find &#x2F;c &quot;.exe&quot;\n管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令\n该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数\ntype c:test.txt|more\n这个和 more c:test.txt 的效果是一样的\n\n26 &gt; 和 &gt;&gt;\n输出重定向命令\n &gt; 清除文件中原有的内容后再写入\n &gt;&gt; 追加内容到文件末尾，而不会清除原有的内容\n主要将本来显示在屏幕上的内容输出到指定文件中\n指定文件如果不存在，则自动生成该文件\ntype c:test.txt &gt;prn\n屏幕上不显示文件内容，转向输出到打印机\necho hello world&gt;con\n在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的\ncopy c:test.txt f: &gt;nul\n拷贝文件，并且不显示&quot;文件复制成功&quot;的提示信息，但如果f盘不存在，还是会显示出错信息\ncopy c:test.txt f: &gt;nul 2&gt;nul\n不显示”文件复制成功”的提示信息，并且f盘不存在的话，也不显示错误提示信息\necho ^^W ^&gt; ^W&gt;c:test.txt\n生成的文件内容为 ^W &gt; W\n^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号\n\n27 &lt;\n从文件中获得输入信息，而不是从屏幕上\n一般用于 date time label 等需要等待输入的命令\n@echo off\necho 2005-05-01&gt;temp.txt\ndate &lt;temp.txt\ndel temp.txt\n这样就可以不等待输入直接修改当前日期\n\n28 %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*\n命令行传递给批处理的参数\n%0 批处理文件本身\n%1 第一个参数\n%9 第九个参数\n%* 从第一个参数开始的所有参数\n\n批参数(%n)的替代已被增强。您可以使用以下语法:\n\n​     %~1          - 删除引号(&quot;)，扩充 %1\n​     %~f1         - 将 %1 扩充到一个完全合格的路径名\n​     %~d1         - 仅将 %1 扩充到一个驱动器号\n​     %~p1         - 仅将 %1 扩充到一个路径\n​     %~n1         - 仅将 %1 扩充到一个文件名\n​     %~x1         - 仅将 %1 扩充到一个文件扩展名\n​     %~s1         - 扩充的路径指含有短名\n​     %~a1         - 将 %1 扩充到文件属性\n​     %~t1         - 将 %1 扩充到文件的日期&#x2F;时间\n​     %~z1         - 将 %1 扩充到文件的大小\n​     %~$PATH : 1 - 查找列在 PATH 环境变量的目录，并将 %1\n​                   扩充到找到的第一个完全合格的名称。如果环境\n​                   变量名未被定义，或者没有找到文件，此组合键会\n​                   扩充到空字符串\n\n可以组合修定符来取得多重结果:\n\n​    %~dp1        - 只将 %1 扩展到驱动器号和路径\n​    %~nx1        - 只将 %1 扩展到文件名和扩展名\n​    %~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1，\n​                   并扩展到找到的第一个文件的驱动器号和路径。\n​    %~ftza1      - 将 %1 扩展到类似 DIR 的输出行。\n可以参照 call&#x2F;? 或 for&#x2F;? 看出每个参数的含意\necho load &quot;%%1&quot; &quot;%%2&quot;&gt;c:test.txt\n生成的文件内容为 load &quot;%1&quot; &quot;%2&quot;\n批处理文件里，用这个格式把命令行参数输出到文件\n\n29 if\n判断命令\nif &quot;%1&quot;&#x3D;&#x3D;&quot;&#x2F;a&quot; echo 第一个参数是&#x2F;a\nif &#x2F;i &quot;%1&quot; equ &quot;&#x2F;a&quot; echo 第一个参数是&#x2F;a\n&#x2F;i 表示不区分大小写，equ 和 &#x3D;&#x3D; 是一样的，其它运算符参见 if&#x2F;?\nif exist c:test.bat echo 存在c:test.bat文件\nif not exist c:windows (\n     echo 不存在c:windows文件夹\n     )\nif exist c:test.bat (\n     echo 存在c:test.bat\n     ) else (\n     echo 不存在c:test.bat\n     )\n\n30 setlocal 和 endlocal\n设置”命令扩展名”和”延缓环境变量扩充”\nSETLOCAL ENABLEEXTENSIONS             #启用&quot;命令扩展名&quot;\nSETLOCAL DISABLEEXTENSIONS            #停用&quot;命令扩展名&quot;\nSETLOCAL ENABLEDELAYEDEXPANSION       #启用&quot;延缓环境变量扩充&quot;\nSETLOCAL DISABLEDELAYEDEXPANSION      #停用&quot;延缓环境变量扩充&quot;\nENDLOCAL                              #恢复到使用SETLOCAL语句以前的状态\n“命令扩展名”默认为启用\n“延缓环境变量扩充”默认为停用\n批处理结束系统会自动恢复默认值\n可以修改注册表以禁用&quot;命令扩展名&quot;，详见 cmd &#x2F;? 。所以用到&quot;命令扩展名&quot;的程\n序，建议在开头和结尾加上 SETLOCAL ENABLEEXTENSIONS 和 ENDLOCAL 语句，以确\n保程序能在其它系统上正确运行\n&quot;延缓环境变量扩充&quot;主要用于 if 和 for 的符合语句，在 set 的说明里有其实用例程\n\n31 set\n设置变量\n引用变量可在变量名前后加 % ，即 %变量名%\nset                     #显示目前所有可用的变量，包括系统变量和自定义的变量\necho %SystemDrive%      #显示系统盘盘符。系统变量可以直接引用\nset p                   #显示所有以p开头的变量，要是一个也没有就设errorlevel&#x3D;1\nset p&#x3D;aa1bb1aa2bb2      #设置变量p，并赋值为 &#x3D; 后面的字符串，即aa1bb1aa2bb2\necho %p%                #显示变量p代表的字符串，即aa1bb1aa2bb2\necho %p:~6%             #显示变量p中第6个字符以后的所有字符，即aa2bb2\necho %p:~6,3%           #显示第6个字符以后的3个字符，即aa2\necho %p:~0,3%           #显示前3个字符，即aa1\necho %p:~-2%            #显示最后面的2个字符，即b2\necho %p:~0,-2%          #显示除了最后2个字符以外的其它字符，即aa1bb1aa2b\necho %p:aa&#x3D;c%           #用c替换变量p中所有的aa，即显示c1bb1c2bb2\necho %p:aa&#x3D;%            #将变量p中的所有aa字符串置换为空，即显示1bb12bb2\necho %p:*bb&#x3D;c%          #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2\nset p&#x3D;%p:*bb&#x3D;c%         #设置变量p，赋值为 %p:*bb&#x3D;c% ，即c1aa2bb2\nset &#x2F;a p&#x3D;39             #设置p为数值型变量，值为39\nset &#x2F;a p&#x3D;39&#x2F;10          #支持运算符，有小数时用去尾法，39&#x2F;10&#x3D;3.9，去尾得3，p&#x3D;3\nset &#x2F;a p&#x3D;p&#x2F;10           #用 &#x2F;a 参数时，在 &#x3D; 后面的变量可以不加%直接引用\nset &#x2F;a p&#x3D;”1&amp;0″          #”与”运算，要加引号。其它支持的运算符参见set&#x2F;?\nset p&#x3D;                  #取消p变量\nset &#x2F;p p&#x3D;请输入\n屏幕上显示”请输入”，并会将输入的字符串赋值给变量p\n注意这条可以用来取代 choice 命令\n注意变量在 if 和 for 的复合语句里是一次性全部替换的，如\n@echo off\nset p&#x3D;aaa\nif %p%&#x3D;&#x3D;aaa (\n     echo %p%\n     set p&#x3D;bbb\n     echo %p%\n     )\n结果将显示\naaa\naaa\n因为在读取 if 语句时已经将所有 %p% 替换为aaa\n这里的&quot;替换&quot;，在 &#x2F;? 帮助里就是指&quot;扩充&quot;、&quot;环境变量扩充&quot;\n可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!\n@echo off\nSETLOCAL ENABLEDELAYEDEXPANSION\nset p&#x3D;aaa\nif %p%&#x3D;&#x3D;aaa (\n     echo %p%\n     set p&#x3D;bbb\n     echo !p!\n     )\nENDLOCAL\n结果将显示\naaa\nbbb\n还有几个动态变量，运行 set 看不到\n%CD%                   #代表当前目录的字符串\n%DATE%                 #当前日期\n%TIME%                 #当前时间\n%RANDOM%               #随机整数，介于0~32767\n%ERRORLEVEL%           #当前 ERRORLEVEL 值\n%CMDEXTVERSION%        #当前命令处理器扩展名版本号\n%CMDCMDLINE%           #调用命令处理器的原始命令行\n可以用echo命令查看每个变量值，如 echo %time%\n注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到\n\n32 start\n批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令\n\n33 call\n批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行\n有时有的应用程序用start调用出错的，也可以call调用\n\n34 choice (外部命令)\n选择命令\n让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……\nwin98里是[http:&#x2F;&#x2F;choice.com](https:&#x2F;&#x2F;link.zhihu.com&#x2F;?target&#x3D;http%3A&#x2F;&#x2F;choice.com)\nwin2000pro里没有，可以从win98里拷过来\nwin2003里是choice.exe\nchoice &#x2F;N &#x2F;C y &#x2F;T 5 &#x2F;D y&gt;nul\n延时5秒\n\n35 assoc 和 ftype\n文件关联\nassoc 设置&#39;文件扩展名&#39;关联，关联到&#39;文件类型&#39;\nftype 设置&#39;文件类型&#39;关联，关联到&#39;执行程序和参数&#39;\n当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开\n而是先判断.txt属于 txtfile &#39;文件类型&#39;\n再调用 txtfile 关联的命令行 txtfile&#x3D;%SystemRoot%system32NOTEPAD.EXE %1\n可以在&quot;文件夹选项&quot;→&quot;文件类型&quot;里修改这2种关联\nassoc            #显示所有&#39;文件扩展名&#39;关联\nassoc .txt       #显示.txt代表的&#39;文件类型&#39;，结果显示 .txt&#x3D;txtfile\nassoc .doc       #显示.doc代表的&#39;文件类型&#39;，结果显示 .doc&#x3D;Word.Document.8\nassoc .exe       #显示.exe代表的&#39;文件类型&#39;，结果显示 .exe&#x3D;exefile\nftype            #显示所有&#39;文件类型&#39;关联\nftype exefile    #显示exefile类型关联的命令行，结果显示 exefile&#x3D;&quot;%1&quot; %*\nassoc .txt&#x3D;Word.Document.8\n设置.txt为word类型的文档，可以看到.txt文件的图标都变了\nassoc .txt&#x3D;txtfile\n恢复.txt的正确关联\nftype exefile&#x3D;&quot;%1&quot; %*\n恢复 exefile 的正确关联\n如果该关联已经被破坏，可以运行 [http:&#x2F;&#x2F;command.com](https:&#x2F;&#x2F;link.zhihu.com&#x2F;?target&#x3D;http%3A&#x2F;&#x2F;command.com) ，再输入这条命令\n\n36 pushd 和 popd\n切换当前目录\n@echo off\nc: &amp; cd &amp; md mp3        #在 C: 建立 mp3 文件夹\nmd d:mp4                #在 D: 建立 mp4 文件夹\ncd &#x2F;d d:mp4             #更改当前目录为 d:mp4\npushd c:mp3             #保存当前目录，并切换当前目录为 c:mp3\npopd                     #恢复当前目录为刚才保存的 d:mp4\n\n37 for\n循环命令\n这个比较复杂，请对照 for&#x2F;? 来看\nfor %%i in (c: d: e: f:) do echo %%i\n依次调用小括号里的每个字符串，执行 do 后面的命令\n注意%%i，在批处理中 for 语句调用参数用2个%\n默认的字符串分隔符是&quot;空格键&quot;，&quot;Tab键&quot;，&quot;回车键&quot;\nfor %%i in (*.txt) do find &quot;abc&quot; %%i\n对当前目录里所有的txt文件执行 find 命令\nfor &#x2F;r . %%i in (*.txt) do find &quot;abc&quot; %%i\n在当前目录和子目录里所有的.txt文件中搜索包含 abc 字符串的行\nfor &#x2F;r . %%i in (.) do echo %%~pni\n显示当前目录名和所有子目录名，包括路径，不包括盘符\nfor &#x2F;r d:mp3 %%i in (*.mp3) do echo %%i&gt;&gt;d:mp3.txt\n把 d:mp3 及其子目录里的mp3文件的文件名都存到 d:mp3.txt 里去\nfor &#x2F;l %%i in (2,1,8) do echo %%i\n生成2345678的一串数字，2是数字序列的开头，8是结尾，1表示每次加1\nfor &#x2F;f %%i in (&#39;set&#39;) do echo %%i\n对 set 命令的输出结果循环调用，每行一个\nfor &#x2F;f &quot;eol&#x3D;P&quot; %%i in (&#39;set&#39;) do echo %%i\n取 set 命令的输出结果，忽略以 P 开头的那几行\nfor &#x2F;f %%i in (d:mp3.txt) do echo %%i\n显示 d:mp3.txt 里的每个文件名，每行一个，不支持带空格的名称\nfor &#x2F;f &quot;delims&#x3D;&quot; %%i in (d:mp3.txt) do echo %%i\n显示 d:mp3.txt 里的每个文件名，每行一个，支持带空格的名称\nfor &#x2F;f &quot;skip&#x3D;5 tokens&#x3D;4&quot; %%a in (&#39;dir&#39;) do echo %%a\n对 dir 命令的结果，跳过前面5行，余下的每行取第4列\n每列之间的分隔符为默认的&quot;空格&quot;\n可以注意到 dir 命令输出的前5行是没有文件名的\nfor &#x2F;f &quot;tokens&#x3D;1,2,3 delims&#x3D;- &quot; %%a in (&#39;date &#x2F;t&#39;) do (\n     echo %%a\n     echo %%b\n     echo %%c\n     )\n对 date &#x2F;t 的输出结果，每行取1、2、3列\n第一列对应指定的 %%a ，后面的 %%b 和 %%c 是派生出来的，对应其它列\n分隔符指定为 - 和&quot;空格&quot;，注意 delims&#x3D;- 后面有个&quot;空格&quot;\n其中 tokens&#x3D;1,2,3 若用 tokens&#x3D;1-3 替换，效果是一样的\nfor &#x2F;f &quot;tokens&#x3D;2* delims&#x3D;- &quot; %%a in (&#39;date &#x2F;t&#39;) do echo %%b\n取第2列给 %%a ，其后的列都给 %%b\n\n38 subst (外部命令)\n映射磁盘。\nsubst z: serverd      #这样输入z:就可以访问serverd了\nsubst z: &#x2F;d              #取消该映射\nsubst                    #显示目前所有的映时\n\n39 xcopy (外部命令)\n文件拷贝\nxcopy d:mp3 e:mp3 &#x2F;s&#x2F;e&#x2F;i&#x2F;y\n复制 d:mp3 文件夹、所有子文件夹和文件到 e: ，覆盖已有文件\n加 &#x2F;i 表示如果 e: 没有 mp3 文件夹就自动新建一个，否则会有询问","slug":"bat","date":"2020-10-10T02:13:36.000Z","categories_index":"windows","tags_index":"脚本","author_index":"云の博客"},{"id":"26ec55026225b6b5ca6c99aa5ca72e1f","title":"Elasticsearch的安装与使用","content":"Elasticsearch的安装与使用\n\n\n\n\n1.  Elasticsearch1.1 elasticsearch（默认端口号9200）\n\n\n\n\n\n\n\n\n官方下载地址：链接\n\n\n\n1.2 ik分词器 pinyin分词器配置\n链接： ik分词器 pinyin分词器1.2.1 配置\n1.2.1 配置\n\n配置后需重启es生效\n\n\n1.2.2 ik配置停止词 扩展词 dic\n\n\n\n\n\n1.2 Kibana 安装（默认端口号5601）\nKibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，并让您在 Elastic Stack 中进行导航。您可以进行各种操作，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。\n下载链接\n\n \n\n\n1.3 elasticsearch配合mysql实现全文搜索\n\n\n\n\n\n\n\n\n1.3.1 下载安装logstash\n\n\n\n\n先解压下载的压缩包然后安装插件  \n命令分别是(在Logstash主目录下运行)：\nlogstash-plugin install logstash-input-jdbc\nlogstash-plugin install logstash-output-elasticsearch\n\n\n\n\n\n\n\n\n\n1.3.2 下载mysql驱动\n\n\n\n\n1.3.3新建添加配置文件\n1. 新建配置文件 mysqltoes.conf2.input &#123;\n  jdbc &#123;\n    jdbc_driver_library &#x3D;&gt; &quot;F:\\ES\\ES6.5.4\\logstash-6.5.4\\bin\\mysql-connector-java-5.1.49-bin.jar&quot;\n    jdbc_driver_class &#x3D;&gt; &quot;com.mysql.jdbc.Driver&quot;\n    jdbc_connection_string &#x3D;&gt; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cms?characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false&quot;\n    jdbc_user &#x3D;&gt; &quot;root&quot;\n    jdbc_password &#x3D;&gt; &quot;123456&quot;\n    statement &#x3D;&gt; &quot;SELECT * FROM news_content&quot;\n\tuse_column_value &#x3D;&gt; true\n\ttracking_column &#x3D;&gt; &quot;updatetime&quot;\n    jdbc_paging_enabled &#x3D;&gt; &quot;true&quot;\n    jdbc_page_size &#x3D;&gt; &quot;50000&quot;\n    schedule &#x3D;&gt; &quot;* * * * *&quot;\n  &#125;\n&#125;\n \nfilter &#123;\n\n date &#123;\n    # 有多个项的话能匹配多个不同的格式\n    match &#x3D;&gt; [ &quot;logdate&quot;, &quot;MMM dd yyyy HH:mm:ss&quot;,&quot;ISO8601&quot; ]\n    target &#x3D;&gt; &quot;fieldName1&quot;\n    timezone &#x3D;&gt; &quot;Asia&#x2F;Shanghai&quot;\n  &#125;\n  \n   json &#123;\n        source &#x3D;&gt; &quot;message&quot;\n        remove_field &#x3D;&gt; [&quot;message&quot;]\n    &#125;\n&#125;\n \noutput &#123;\n  stdout &#123;\n    codec &#x3D;&gt; rubydebug\n  &#125;\n  elasticsearch &#123;\n    hosts &#x3D;&gt; &quot;localhost:9200&quot;\n    index &#x3D;&gt; &quot;news_content&quot;\n\t #指定类型，任意\n        document_type &#x3D;&gt; &quot;doc&quot;\n        document_id &#x3D;&gt; &quot;%&#123;id&#125;&quot;\n  &#125;       \n&#125;\n\n\ninput 配置参考：https://www.elastic.co/guide/en/logstash/current/input-plugins.html        output 配置参考：https://www.elastic.co/guide/en/logstash/current/output-plugins.html        filter 配置参考：https://www.elastic.co/guide/en/logstash/6.4/filter-plugins.html        Logstash Reference：https://www.elastic.co/guide/en/logstash/6.4/index.html\n3. 启动logstash （ logstash -f mysqltoes.conf ）\n\n\n\nindex - 索引名\nq - 查询指定匹配 使用Lucene查询语法\nfrom_ - 查询起始点 默认0\ndoc_type - 文档类型\nsize - 指定查询条数 默认10\nfield - 指定字段 逗号分隔\nsort - 排序 字段：asc&#x2F;desc\nbody - 使用Query DSL\nscroll - 滚动查询\ntook是耗时，毫秒单位\ntime_out 是否超时\ntotal 分片\nhits下面\ntotal：结果总数\nmax_score：相似度\nid：文档唯一标识\n\n2、Elasticsearch项目windows服务注册\n2.1 Elasticsearch 注册服务命令：service install Elasticsearch2.2 kibana 注册服务命令：nssm.exe install kibana.bat2.3 logtash 注册服务命令：nssm.exe install logstash “ logstash\\bin\\logstash.bat” “agent -f logstash\\bin\\mysqltoes.conf”\n","slug":"elasticsearch","date":"2020-07-23T02:39:36.000Z","categories_index":"java","tags_index":"分布式,搜索服务","author_index":"云の博客"},{"id":"2fdfe1e1ace8a4912a23a4cbc1c92824","title":"SpringCloud","content":"SpringCloud微服务\n\n\n\n关于微服务 \nSpringCloud和SpringBoot的关系SpringBoot专注于方便快速的开发单个个体的微服务\nSpringCloud关注全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。\nSpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。\nEureka服务注册与发现(AP原则)Eureka是一种基于REST（Representational State Transfer）的服务，主要用于AWS云，用于定位服务，以实现中间层服务器的负载平衡和故障转移。\nCAP C:Consistency(强一致性) \tA:Availability(可用性) P:Partition tolerance(分区容错性)参考官网\nRibbon负载均衡SpringCloud Ribbon是基于Netflix Ribbon实现的一套客户端 \n参考官网\nFeign负载均衡Feign是一个声明式的Web服务客户端，使得编写Web服务客户端变得非常容易\n只需要创建一个接口，然后在上面添加注解即可\n参考官网\nHystrix 断路器Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式以系统的弹性。\n参考官网\nZuul路由网关Zuul是一项边缘服务，提供动态路由，监控，弹性，安全性等。请查看维基用途，信息，HOWTO等\n参考官网\nSpringCloud Config 分布式配置中心SpringCloud Config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n参考官网\n","slug":"springcloud","date":"2019-01-14T11:38:48.000Z","categories_index":"java","tags_index":"Spring,SpringCloud","author_index":"云の博客"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"Docker的安装与使用\n\n\n\nDocker安装安装链接：链接1&amp;emsp;链接2Docker_阿里云镜像加速配置\n打开阿里云容器镜像服务：https://cr.console.aliyun.com/cn-hangzhou/mirrors\n\n\nvim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n{“registry-mirrors”: [“https://5wfalegv.mirror.aliyuncs.com&quot;]}\n\nsudo systemctl daemon-reload\n\nsudo systemctl restart docker\n\n\n镜像命令\ndocker images   列出本地主机上的镜像\n-a 列出本地所有的镜像（含中间映像层）\n-q 只显示镜像ID\n–digests 显示镜像的摘要信息\n–no-trunc 显示完整的镜像信息\n\n\ndocker search\n–no-trunc 显示完整的镜像描述\n-s 列出收藏数不小于指定值的镜像\n–automated 只列出automated build类型的镜像\n\n\ndocker pull  下载镜像\ndocker rmi\n删除单个 docker rmi -f 镜像ID\n删除多个 docker rmi -f 镜像名1：tag  镜像名2：tag\n删除全部 docker rmi -f $(docker images -qa)\n\n\n\n容器命令\n创建并启动容器\tdocker run [OPTIONS] images [COMMAND] [ARG…]\n\nOPTIONS说明\n\n–name&#x3D;”容器新名字”\n\n-d 后台运行容器，并返回容器ID，也即启动守护式容器\n\n-i 以交互模式运行容器，通常与-t同时使用\n\n-t 为容器重新分配一个伪输入终端，通常与-i同时使用\n\n-P 随机端口映射\n\n-p 指定端口映射，有以下四种格式\n  ip:hostPort:containerPort\n  ip::containerPort\n  hostPort:containerPort\n  containerPort\n\n\n\n列出当前所有正在运行的容器  docker ps[OPTIONS]\n\n-a 列出当前正在运行的容器和历史运行容器\n-l 显示最近创建的容器\n-n 显示最近n个创建的容器\n-q 显示容器编号\n–no-trunc 不截断输出\n\n\n退出容器 exit 容器停止退出    ctrl+P+Q 容器不停止退出\n\n重启容器  docker restart 容器名|容器ID\n\n停止容器  docker stop 容器名|容器ID\n\n强制停止容器 docker kill 容器名|容器ID\n\n删除已停止的容器 docker rm 容器ID\n\n启动守护式容器  docker run -d 容器名\n\n查看容器日志  docker logs -f -t –tail  容器ID\n\n-t 是加入时间戳\n-f 跟随最新的日志打印\n–tail 数字显示最后多少条\n\n\n查看正在运行的进程 docker top 容器ID\n\n查看容器内部细节 docker inspect 容器ID\n\n进入正在运行的容器并以命令行交互\n\ndocker exec -it 容器ID bashShell（例：docker exec -it 6ef2868b0e41 &#x2F;bin&#x2F;bash）exec 在容器中打开新的终端，并且可以启动新的进程\ndocker attach 容器ID  attach 直接进入容器启动命令的终端，不会启动新的进程\n\n\nDocker镜像commoit操作补充  docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]\n\n\n\n\n容器数据卷\n直接命令添加\t\t\n\ndocker run -it -v &#x2F;宿主机绝对路径:&#x2F;容器内目录  镜像名\n(带权限) docker run -it -v &#x2F;宿主机绝对路径:&#x2F;容器内目录:ro  镜像名\n\n\nDockerFile添加\n\nFile构建\n\nbuild后生成镜像 docker build -f  &#x2F;dockerfile文件路径 -t 命名 .\n\nrun容器\n\n\n\n\nDockerFile解析\nDockerFile体系结构\n\nFROM                 基础镜像，当前镜像是基于哪个镜像的\nMAINTAINER   镜像维护者的姓名和邮箱地址\nRUN                    容器构建时需要运行的命令\nEXPOSE             当前容器对外暴露出的端口\nWORKDIR         指定在创建容器后，终端默认登录的竟来工作目录\nENV                    用来构建镜像过程中设置环境变量\nADD                    将宿主机目录下的文件拷贝到镜像且ADD命令会自动处理URL和解压tar压缩包\nCOPY                  类似ADD,拷贝文件个目录到镜像中。将从构建上下而我呢目录中&lt;源路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。\nVOLUME            容器数据卷，用于数据保存个持久化工作\nCMD                    指定一个容器启动时要运行的命令。DockerFile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换\nENTRYPOINT    指定一个容器启动时要运行的命令。ENTRYPOINT和CMD一样，都是在指定容器启动程序及参数\nONBUILD           当构建一个被继承的Dockerfile时运行命令，父镜像在被子镜像继承后父镜像的onbuild被触发。\n\n\n\n将本地镜像推送到阿里云\n创建镜像仓库\n\n\n将镜像推送到registry​\t\n$ sudo docker login --username&#x3D;suvwwg registry.cn-hangzhou.aliyuncs.com\n$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com&#x2F;wwg&#x2F;mytomcat:[镜像版本号]\n$ sudo docker push registry.cn-hangzhou.aliyuncs.com&#x2F;wwg&#x2F;mytomcat:[镜像版本号]\n\n​    \n  ​\t\t  \t\t\n","slug":"docker","date":"2019-01-11T02:59:39.000Z","categories_index":"linux","tags_index":"虚拟化","author_index":"云の博客"},{"id":"af912e0d33a827f03582ef107fe8a87d","title":"SpringBoot","content":"Spring Boot\n\n\n\n1、Spring Boot 简介\n\n\n\n\n\n\n\n\n简化Spring应用开发的一个框架；\n整个Spring技术栈的一个大整合；\nJ2EE开发的一站式解决方案；\n2、微服务2014，martin fowler\n微服务：架构风格（服务微化）\n一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\n单体应用：ALL IN ONE\n微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\n详细参照微服务文档\n3、环境准备http://www.gulixueyuan.com/ 谷粒学院\n环境约束\n–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”\n–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9\n–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS\n–SpringBoot 1.5.9.RELEASE：1.5.9；\n统一环境；\n1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加\n&lt;profile&gt;\n  &lt;id&gt;jdk-1.8&lt;&#x2F;id&gt;\n  &lt;activation&gt;\n    &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;\n    &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;\n  &lt;&#x2F;activation&gt;\n  &lt;properties&gt;\n    &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;\n    &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;\n    &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt;\n  &lt;&#x2F;properties&gt;\n&lt;&#x2F;profile&gt;\n\n2、IDEA设置整合maven进来；\n\n\n4、Spring Boot HelloWorld一个功能：\n浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；\n1、创建一个maven工程；（jar）2、导入spring boot相关的依赖&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.5.9.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n3、编写一个主程序；启动Spring Boot应用\n&#x2F;**\n *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用\n *&#x2F;\n@SpringBootApplication\npublic class HelloWorldMainApplication &#123;\n\n    public static void main(String[] args) &#123;\n\n        &#x2F;&#x2F; Spring应用启动起来\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    &#125;\n&#125;\n\n4、编写相关的Controller、Service@Controller\npublic class HelloController &#123;\n\n    @ResponseBody\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String hello()&#123;\n        return &quot;Hello World!&quot;;\n    &#125;\n&#125;\n\n\n\n\n5、运行主程序测试6、简化部署&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;\n   &lt;build&gt;\n       &lt;plugins&gt;\n           &lt;plugin&gt;\n               &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n               &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n           &lt;&#x2F;plugin&gt;\n       &lt;&#x2F;plugins&gt;\n   &lt;&#x2F;build&gt;\n\n将这个应用打成jar包，直接使用java -jar的命令进行执行；\n5、Hello World探究1、POM文件1、父项目&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.5.9.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n他的父项目是\n&lt;parent&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.5.9.RELEASE&lt;&#x2F;version&gt;\n  &lt;relativePath&gt;..&#x2F;..&#x2F;spring-boot-dependencies&lt;&#x2F;relativePath&gt;\n&lt;&#x2F;parent&gt;\n他来真正管理Spring Boot应用里面的所有依赖版本；\n\n\nSpring Boot的版本仲裁中心；\n以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）\n2、启动器&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nspring-boot-starter-&#x3D;&#x3D;web&#x3D;&#x3D;：\n​\tspring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n2、主程序类，主入口类&#x2F;**\n *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用\n *&#x2F;\n@SpringBootApplication\npublic class HelloWorldMainApplication &#123;\n\n    public static void main(String[] args) &#123;\n\n        &#x2F;&#x2F; Spring应用启动起来\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    &#125;\n&#125;\n\n\n@SpringBootApplication:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters &#x3D; &#123;\n      @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),\n      @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)\npublic @interface SpringBootApplication &#123;\n\n@SpringBootConfiguration:Spring Boot的配置类；\n​\t\t标注在某个类上，表示这是一个Spring Boot的配置类；\n​\t\t@Configuration:配置类上来标注这个注解；\n​\t\t\t配置类 —–  配置文件；配置类也是容器中的一个组件；@Component\n@EnableAutoConfiguration：开启自动配置功能；\n​\t\t以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration &#123;\n\n​      \t@AutoConfigurationPackage：自动配置包\n​\t\t@Import(AutoConfigurationPackages.Registrar.class)：\n​\t\tSpring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；\n&#x3D;&#x3D;将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；&#x3D;&#x3D;\n​\t@Import(EnableAutoConfigurationImportSelector.class)；\n​\t\t给容器中导入组件？\n​\t\tEnableAutoConfigurationImportSelector：导入哪些组件的选择器；\n​\t\t将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n​\t\t会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；\t\t\n有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\n​\t\tSpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；\n&#x3D;&#x3D;Spring Boot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；&#x3D;&#x3D;以前我们需要自己配置的东西，自动配置类都帮我们；\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；\n​\t\t\n&#x3D;&#x3D;Spring注解版（谷粒学院）&#x3D;&#x3D;\n6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；\n选择我们需要的模块；向导会联网创建Spring Boot项目；\n默认生成的Spring Boot项目；\n\n主程序已经生成好了，我们只需要我们自己的逻辑\nresources文件夹中目录结构\nstatic：保存所有的静态资源； js css  springboot；\ntemplates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；\napplication.properties：Spring Boot应用的配置文件；可以修改一些默认设置；\n\n\n\n2、STS使用 Spring Starter Project快速创建项目\n二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的；\n•application.properties\n•application.yml\n配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；\nYAML（YAML Ain’t Markup Language）\n​\tYAML  A Markup Language：是一个标记语言\n​\tYAML   isn’t Markup Language：不是一个标记语言；\n标记语言：\n​\t以前的配置文件；大多都使用的是  xxxx.xml文件；\n​\tYAML：以数据为中心，比json、xml等更适合做配置文件；\n​\tYAML：配置例子\nserver:\n  port: 8081\n\n​\tXML：\n&lt;server&gt;\n\t&lt;port&gt;8081&lt;&#x2F;port&gt;\n&lt;&#x2F;server&gt;\n\n\n\n2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）；\n以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的\nserver:\n    port: 8081\n    path: &#x2F;hello\n\n属性和值也是大小写敏感；\n2、值的写法字面量：普通的值（数字，字符串，布尔）​\tk: v：字面直接来写；\n​\t\t字符串默认不用加上单引号或者双引号；\n​\t\t“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思\n​\t\t\t\tname:   “zhangsan \\n lisi”：输出；zhangsan 换行  lisi\n​\t\t‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据\n​\t\t\t\tname:   ‘zhangsan \\n lisi’：输出；zhangsan \\n  lisi\n对象、Map（属性和值）（键值对）：​\tk: v：在下一行来写对象的属性和值的关系；注意缩进\n​\t\t对象还是k: v的方式\nfriends:\n\t\tlastName: zhangsan\n\t\tage: 20\n\n行内写法：\nfriends: &#123;lastName: zhangsan,age: 18&#125;\n\n\n\n数组（List、Set）：用- 值表示数组中的一个元素\npets:\n - cat\n - dog\n - pig\n\n行内写法\npets: [cat,dog,pig]\n\n\n\n3、配置文件值注入配置文件\nperson:\n    lastName: hello\n    age: 18\n    boss: false\n    birth: 2017&#x2F;12&#x2F;12\n    maps: &#123;k1: v1,k2: 12&#125;\n    lists:\n      - lisi\n      - zhaoliu\n    dog:\n      name: 小狗\n      age: 12\n\njavaBean：\n&#x2F;**\n * 将配置文件中配置的每一个属性的值，映射到这个组件中\n * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\n *      prefix &#x3D; &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射\n *\n * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\n *\n *&#x2F;\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\npublic class Person &#123;\n\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n    private Date birth;\n\n    private Map&lt;String,Object&gt; maps;\n    private List&lt;Object&gt; lists;\n    private Dog dog;\n\n\n\n\n我们可以导入配置文件处理器，以后编写配置就有提示了\n&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n\t\t\t&lt;optional&gt;true&lt;&#x2F;optional&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\n1、properties配置文件在idea中默认utf-8可能会乱码调整\n\n2、@Value获取值和@ConfigurationProperties获取值比较\n\n\n\n@ConfigurationProperties\n@Value\n\n\n\n功能\n批量注入配置文件中的属性\n一个个指定\n\n\n松散绑定（松散语法）\n支持\n不支持\n\n\nSpEL\n不支持\n支持\n\n\nJSR303数据校验\n支持\n不支持\n\n\n复杂类型封装\n支持\n不支持\n\n\n配置文件yml还是properties他们都能获取到值；\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；\n3、配置文件注入值数据校验@Component\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n@Validated\npublic class Person &#123;\n\n    &#x2F;**\n     * &lt;bean class&#x3D;&quot;Person&quot;&gt;\n     *      &lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;字面量&#x2F;$&#123;key&#125;从环境变量、配置文件中获取值&#x2F;#&#123;SpEL&#125;&quot;&gt;&lt;&#x2F;property&gt;\n     * &lt;bean&#x2F;&gt;\n     *&#x2F;\n\n   &#x2F;&#x2F;lastName必须是邮箱格式\n    @Email\n    &#x2F;&#x2F;@Value(&quot;$&#123;person.last-name&#125;&quot;)\n    private String lastName;\n    &#x2F;&#x2F;@Value(&quot;#&#123;11*2&#125;&quot;)\n    private Integer age;\n    &#x2F;&#x2F;@Value(&quot;true&quot;)\n    private Boolean boss;\n\n    private Date birth;\n    private Map&lt;String,Object&gt; maps;\n    private List&lt;Object&gt; lists;\n    private Dog dog;\n\n\n\n4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件；\n&#x2F;**\n * 将配置文件中配置的每一个属性的值，映射到这个组件中\n * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\n *      prefix &#x3D; &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射\n *\n * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\n *  @ConfigurationProperties(prefix &#x3D; &quot;person&quot;)默认从全局配置文件中获取值；\n *\n *&#x2F;\n@PropertySource(value &#x3D; &#123;&quot;classpath:person.properties&quot;&#125;)\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n&#x2F;&#x2F;@Validated\npublic class Person &#123;\n\n    &#x2F;**\n     * &lt;bean class&#x3D;&quot;Person&quot;&gt;\n     *      &lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;字面量&#x2F;$&#123;key&#125;从环境变量、配置文件中获取值&#x2F;#&#123;SpEL&#125;&quot;&gt;&lt;&#x2F;property&gt;\n     * &lt;bean&#x2F;&gt;\n     *&#x2F;\n\n   &#x2F;&#x2F;lastName必须是邮箱格式\n   &#x2F;&#x2F; @Email\n    &#x2F;&#x2F;@Value(&quot;$&#123;person.last-name&#125;&quot;)\n    private String lastName;\n    &#x2F;&#x2F;@Value(&quot;#&#123;11*2&#125;&quot;)\n    private Integer age;\n    &#x2F;&#x2F;@Value(&quot;true&quot;)\n    private Boolean boss;\n\n\n\n\n@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上\n@ImportResource(locations &#x3D; &#123;&quot;classpath:beans.xml&quot;&#125;)\n导入Spring的配置文件让其生效\n\n\n\n不来编写Spring的配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n\n    &lt;bean id&#x3D;&quot;helloService&quot; class&#x3D;&quot;com.atguigu.springboot.service.HelloService&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\nSpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式\n1、配置类**@Configuration**——&gt;Spring配置文件\n2、使用**@Bean**给容器中添加组件\n&#x2F;**\n * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件\n *\n * 在配置文件中用&lt;bean&gt;&lt;bean&#x2F;&gt;标签添加组件\n *\n *&#x2F;\n@Configuration\npublic class MyAppConfig &#123;\n\n    &#x2F;&#x2F;将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\n    @Bean\n    public HelloService helloService02()&#123;\n        System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;);\n        return new HelloService();\n    &#125;\n&#125;\n\n##4、配置文件占位符\n1、随机数$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;\n$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125;\n\n\n\n\n2、占位符获取之前配置的值，如果没有可以是用:指定默认值person.last-name&#x3D;张三$&#123;random.uuid&#125;\nperson.age&#x3D;$&#123;random.int&#125;\nperson.birth&#x3D;2017&#x2F;12&#x2F;15\nperson.boss&#x3D;false\nperson.maps.k1&#x3D;v1\nperson.maps.k2&#x3D;14\nperson.lists&#x3D;a,b,c\nperson.dog.name&#x3D;$&#123;person.hello:hello&#125;_dog\nperson.dog.age&#x3D;15\n\n\n\n5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties&#x2F;yml\n默认使用application.properties的配置；\n2、yml支持多文档块方式\nserver:\n  port: 8081\nspring:\n  profiles:\n    active: prod\n\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev\n\n\n---\n\nserver:\n  port: 8084\nspring:\n  profiles: prod  #指定属于哪个环境\n\n\n\n\n\n3、激活指定profile​\t1、在配置文件中指定  spring.profiles.active&#x3D;dev\n​\t2、命令行：\n​\t\tjava -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active&#x3D;dev；\n​\t\t可以直接在测试的时候，配置传入命令行参数\n​\t3、虚拟机参数；\n​\t\t-Dspring.profiles.active&#x3D;dev\n6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n–file:.&#x2F;config&#x2F;\n–file:.&#x2F;\n–classpath:&#x2F;config&#x2F;\n–classpath:&#x2F;\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\nSpringBoot会从这四个位置全部加载主配置文件；互补配置；\n&#x3D;&#x3D;我们还可以通过spring.config.location来改变默认的配置文件位置&#x3D;&#x3D;\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location&#x3D;G:&#x2F;application.properties\n7、外部配置加载顺序&#x3D;&#x3D;SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置&#x3D;&#x3D;\n1.命令行参数\n所有的配置都可以在命令行上进行指定\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port&#x3D;8087  –server.context-path&#x3D;&#x2F;abc\n多个配置用空格分开； –配置项&#x3D;值\n2.来自java:comp&#x2F;env的JNDI属性\n3.Java系统属性（System.getProperties()）\n4.操作系统环境变量\n5.RandomValuePropertySource配置的random.*属性值\n&#x3D;&#x3D;由jar包外向jar包内进行寻找；&#x3D;&#x3D;\n&#x3D;&#x3D;优先加载带profile&#x3D;&#x3D;\n6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n&#x3D;&#x3D;再来加载不带profile&#x3D;&#x3D;\n8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件\n9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件\n10.@Configuration注解类上的@PropertySource\n11.通过SpringApplication.setDefaultProperties指定的默认属性\n所有支持的配置加载来源；\n参考官方文档\n8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理；\n配置文件能配置的属性参照\n1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 &#x3D;&#x3D;@EnableAutoConfiguration&#x3D;&#x3D;\n2）、@EnableAutoConfiguration 作用：\n\n利用EnableAutoConfigurationImportSelector给容器中导入一些组件？\n\n可以查看selectImports()方法的内容；\n\nList configurations &#x3D; getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置\n\n&#96;&#96;&#96;javaSpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下  META-INF&#x2F;spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中\n\n    \n\n**&#x3D;&#x3D;将 类路径下  META-INF&#x2F;spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；&#x3D;&#x3D;**\n\n&#96;&#96;&#96;properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\n\n\n\n每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；\n3）、每一个自动配置类进行自动配置功能；\n4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；\n@Configuration   &#x2F;&#x2F;表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\n@EnableConfigurationProperties(HttpEncodingProperties.class)  &#x2F;&#x2F;启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中\n\n@ConditionalOnWebApplication &#x2F;&#x2F;Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效\n\n@ConditionalOnClass(CharacterEncodingFilter.class)  &#x2F;&#x2F;判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；\n\n@ConditionalOnProperty(prefix &#x3D; &quot;spring.http.encoding&quot;, value &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; true)  &#x2F;&#x2F;判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的\n&#x2F;&#x2F;即使我们配置文件中不配置pring.http.encoding.enabled&#x3D;true，也是默认生效的；\npublic class HttpEncodingAutoConfiguration &#123;\n  \n  \t&#x2F;&#x2F;他已经和SpringBoot的配置文件映射了\n  \tprivate final HttpEncodingProperties properties;\n  \n   &#x2F;&#x2F;只有一个有参构造器的情况下，参数的值就会从容器中拿\n  \tpublic HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123;\n\t\tthis.properties &#x3D; properties;\n\t&#125;\n  \n    @Bean   &#x2F;&#x2F;给容器中添加一个组件，这个组件的某些值需要从properties中获取\n\t@ConditionalOnMissingBean(CharacterEncodingFilter.class) &#x2F;&#x2F;判断容器没有这个组件？\n\tpublic CharacterEncodingFilter characterEncodingFilter() &#123;\n\t\tCharacterEncodingFilter filter &#x3D; new OrderedCharacterEncodingFilter();\n\t\tfilter.setEncoding(this.properties.getCharset().name());\n\t\tfilter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));\n\t\tfilter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));\n\t\treturn filter;\n\t&#125;\n\n根据当前不同的条件判断，决定这个配置类是否生效？\n一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\n5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类\n@ConfigurationProperties(prefix &#x3D; &quot;spring.http.encoding&quot;)  &#x2F;&#x2F;从配置文件中获取指定的值和bean的属性进行绑定\npublic class HttpEncodingProperties &#123;\n\n   public static final Charset DEFAULT_CHARSET &#x3D; Charset.forName(&quot;UTF-8&quot;);\n\n\n\n\n\n精髓：\n​\t1）、SpringBoot启动会加载大量的自动配置类\n​\t2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；\n​\t3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）\n​\t4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；\nxxxxAutoConfigurartion：自动配置类；\n给容器中添加组件\nxxxxProperties:封装配置文件中相关属性；\n2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n\n\n@Conditional扩展注解\n作用（判断是否满足当前指定条件）\n\n\n\n@ConditionalOnJava\n系统的java版本是否符合要求\n\n\n@ConditionalOnBean\n容器中存在指定Bean；\n\n\n@ConditionalOnMissingBean\n容器中不存在指定Bean；\n\n\n@ConditionalOnExpression\n满足SpEL表达式指定\n\n\n@ConditionalOnClass\n系统中有指定的类\n\n\n@ConditionalOnMissingClass\n系统中没有指定的类\n\n\n@ConditionalOnSingleCandidate\n容器中只有一个指定的Bean，或者这个Bean是首选Bean\n\n\n@ConditionalOnProperty\n系统中指定的属性是否有指定的值\n\n\n@ConditionalOnResource\n类路径下是否存在指定资源文件\n\n\n@ConditionalOnWebApplication\n当前是web环境\n\n\n@ConditionalOnNotWebApplication\n当前不是web环境\n\n\n@ConditionalOnJndi\nJNDI存在指定项\n\n\n自动配置类必须在一定的条件下才能生效；\n我们怎么知道哪些自动配置类生效；\n**&#x3D;&#x3D;我们可以通过启用  debug&#x3D;true属性；来让控制台打印自动配置报告&#x3D;&#x3D;**，这样我们就可以很方便的知道哪些自动配置类生效；\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nAUTO-CONFIGURATION REPORT\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\nPositive matches:（自动配置类启用的）\n-----------------\n\n   DispatcherServletAutoConfiguration matched:\n      - @ConditionalOnClass found required class &#39;org.springframework.web.servlet.DispatcherServlet&#39;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)\n      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)\n        \n    \nNegative matches:（没有启动，没有匹配成功的自动配置类）\n-----------------\n\n   ActiveMQAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required classes &#39;javax.jms.ConnectionFactory&#39;, &#39;org.apache.activemq.ActiveMQConnectionFactory&#39; (OnClassCondition)\n\n   AopAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required classes &#39;org.aspectj.lang.annotation.Aspect&#39;, &#39;org.aspectj.lang.reflect.Advice&#39; (OnClassCondition)\n        \n\n\n\n\n\n三、日志1、日志框架 小张；开发一个大型系统；\n​\t\t1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？\n​\t\t2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；\n​\t\t3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？\n​\t\t4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；\n​\t\t5、JDBC—数据库驱动；\n​\t\t\t写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；\n​\t\t\t给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；\n市面上的日志框架；\nJUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….\n\n\n\n日志门面  （日志的抽象层）\n日志实现\n\n\n\nJCL（Jakarta  Commons Logging）    SLF4j（Simple  Logging Facade for Java）    jboss-logging\nLog4j  JUL（java.util.logging）  Log4j2  Logback\n\n\n左边选一个门面（抽象层）、右边来选一个实现；\n日志门面：  SLF4J；\n日志实现：Logback；\nSpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘\n​\t&#x3D;&#x3D;SpringBoot选用 SLF4j和logback；&#x3D;&#x3D;\n2、SLF4j使用1、如何在系统中使用SLF4j   https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；\n给系统里面导入slf4j的jar和  logback的实现jar\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld &#123;\n  public static void main(String[] args) &#123;\n    Logger logger &#x3D; LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(&quot;Hello World&quot;);\n  &#125;\n&#125;\n\n图示；\n\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；\n2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx\n统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？\n\n如何让系统中所有的日志都统一到slf4j；\n&#x3D;&#x3D;1、将系统中其他日志框架先排除出去；&#x3D;&#x3D;\n&#x3D;&#x3D;2、用中间包来替换原有的日志框架；&#x3D;&#x3D;\n&#x3D;&#x3D;3、我们导入slf4j其他的实现&#x3D;&#x3D;\n3、SpringBoot日志关系&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\nSpringBoot使用它来做日志功能；\n&lt;dependency&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;\n\t&lt;&#x2F;dependency&gt;\n\n底层依赖关系\n\n总结：\n​\t1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录\n​\t2）、SpringBoot也把其他的日志都替换成了slf4j；\n​\t3）、中间替换包？\n@SuppressWarnings(&quot;rawtypes&quot;)\npublic abstract class LogFactory &#123;\n\n    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J &#x3D; &quot;http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#unsupported_operation_in_jcl_over_slf4j&quot;;\n\n    static LogFactory logFactory &#x3D; new SLF4JLogFactory();\n\n\n​\t4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？\n​\t\t\tSpring框架用的是commons-logging；\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;\n\t&lt;exclusions&gt;\n\t\t&lt;exclusion&gt;\n\t\t\t&lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;\n\t\t&lt;&#x2F;exclusion&gt;\n\t&lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n&#x3D;&#x3D;SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；&#x3D;&#x3D;\n4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志；\n&#x2F;&#x2F;记录器\nLogger logger &#x3D; LoggerFactory.getLogger(getClass());\n@Test\npublic void contextLoads() &#123;\n\t&#x2F;&#x2F;System.out.println();\n\n\t&#x2F;&#x2F;日志的级别；\n\t&#x2F;&#x2F;由低到高   trace&lt;debug&lt;info&lt;warn&lt;error\n\t&#x2F;&#x2F;可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\n\tlogger.trace(&quot;这是trace日志...&quot;);\n\tlogger.debug(&quot;这是debug日志...&quot;);\n\t&#x2F;&#x2F;SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别\n\tlogger.info(&quot;这是info日志...&quot;);\n\tlogger.warn(&quot;这是warn日志...&quot;);\n\tlogger.error(&quot;这是error日志...&quot;);\n\n\n&#125;\n\n\n\n    日志输出格式：\n        %d表示日期时间，\n        %thread表示线程名，\n        %-5level：级别从左显示5个字符宽度\n        %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 \n        %msg：日志消息，\n        %n是换行符\n    --&gt;\n    %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n\n\nSpringBoot修改日志的默认配置\nlogging.level.com.atguigu&#x3D;trace\n\n\n#logging.path&#x3D;\n# 不指定路径在当前项目下生成springboot.log日志\n# 可以指定完整的路径；\n#logging.file&#x3D;G:&#x2F;springboot.log\n\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\nlogging.path&#x3D;&#x2F;spring&#x2F;log\n\n#  在控制台输出的日志的格式\nlogging.pattern.console&#x3D;%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n\n# 指定文件中日志输出的格式\nlogging.pattern.file&#x3D;%d&#123;yyyy-MM-dd&#125; &#x3D;&#x3D;&#x3D; [%thread] &#x3D;&#x3D;&#x3D; %-5level &#x3D;&#x3D;&#x3D; %logger&#123;50&#125; &#x3D;&#x3D;&#x3D;&#x3D; %msg%n\n\n\n\n\nlogging.file\nlogging.path\nExample\nDescription\n\n\n\n(none)\n(none)\n\n只在控制台输出\n\n\n指定文件名\n(none)\nmy.log\n输出日志到my.log文件\n\n\n(none)\n指定目录\n&#x2F;var&#x2F;log\n输出到指定目录的 spring.log 文件中\n\n\n2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了\n\n\n\nLogging System\nCustomization\n\n\n\nLogback\nlogback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy\n\n\nLog4j2\nlog4j2-spring.xml or log4j2.xml\n\n\nJDK (Java Util Logging)\nlogging.properties\n\n\nlogback.xml：直接就被日志框架识别了；\nlogback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能\n&lt;springProfile name&#x3D;&quot;staging&quot;&gt;\n    &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;\n  \t可以指定某段配置只在某个环境下生效\n&lt;&#x2F;springProfile&gt;\n\n\n如：\n&lt;appender name&#x3D;&quot;stdout&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;!--\n        日志输出格式：\n\t\t\t%d表示日期时间，\n\t\t\t%thread表示线程名，\n\t\t\t%-5level：级别从左显示5个字符宽度\n\t\t\t%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 \n\t\t\t%msg：日志消息，\n\t\t\t%n是换行符\n        --&gt;\n        &lt;layout class&#x3D;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;\n            &lt;springProfile name&#x3D;&quot;dev&quot;&gt;\n                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;\n            &lt;&#x2F;springProfile&gt;\n            &lt;springProfile name&#x3D;&quot;!dev&quot;&gt;\n                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &#x3D;&#x3D;&#x3D;&#x3D; [%thread] &#x3D;&#x3D;&#x3D;&#x3D; %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;\n            &lt;&#x2F;springProfile&gt;\n        &lt;&#x2F;layout&gt;\n    &lt;&#x2F;appender&gt;\n\n\n\n如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误\n no applicable action for [springProfile]\n5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换；\nslf4j+log4j的方式；\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n  &lt;exclusions&gt;\n    &lt;exclusion&gt;\n      &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;\n      &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;\n    &lt;&#x2F;exclusion&gt;\n    &lt;exclusion&gt;\n      &lt;artifactId&gt;log4j-over-slf4j&lt;&#x2F;artifactId&gt;\n      &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n    &lt;&#x2F;exclusion&gt;\n  &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n\n切换为log4j2\n   &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;\n                    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;&#x2F;exclusion&gt;\n            &lt;&#x2F;exclusions&gt;\n        &lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-log4j2&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n四、Web开发1、简介使用SpringBoot；\n1）、创建SpringBoot应用，选中我们需要的模块；\n2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来\n3）、自己编写业务代码；\n自动配置原理？\n这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx\nxxxxAutoConfiguration：帮我们给容器中自动配置组件；\nxxxxProperties:配置类来封装配置文件的内容；\n\n\n\n\n2、SpringBoot对静态资源的映射规则；@ConfigurationProperties(prefix &#x3D; &quot;spring.resources&quot;, ignoreUnknownFields &#x3D; false)\npublic class ResourceProperties implements ResourceLoaderAware &#123;\n  &#x2F;&#x2F;可以设置和静态资源有关的参数，缓存时间等\n\n\n\nWebMvcAuotConfiguration：\n\t@Override\n\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n\t\tif (!this.resourceProperties.isAddMappings()) &#123;\n\t\t\tlogger.debug(&quot;Default resource handling disabled&quot;);\n\t\t\treturn;\n\t\t&#125;\n\t\tInteger cachePeriod &#x3D; this.resourceProperties.getCachePeriod();\n\t\tif (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123;\n\t\t\tcustomizeResourceHandlerRegistration(\n\t\t\t\t\tregistry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)\n\t\t\t\t\t\t\t.addResourceLocations(\n\t\t\t\t\t\t\t\t\t&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;)\n\t\t\t\t\t.setCachePeriod(cachePeriod));\n\t\t&#125;\n\t\tString staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern();\n         \t&#x2F;&#x2F;静态资源文件夹映射\n\t\tif (!registry.hasMappingForPattern(staticPathPattern)) &#123;\n\t\t\tcustomizeResourceHandlerRegistration(\n\t\t\t\t\tregistry.addResourceHandler(staticPathPattern)\n\t\t\t\t\t\t\t.addResourceLocations(\n\t\t\t\t\t\t\t\t\tthis.resourceProperties.getStaticLocations())\n\t\t\t\t\t.setCachePeriod(cachePeriod));\n\t\t&#125;\n\t&#125;\n\n       &#x2F;&#x2F;配置欢迎页映射\n\t@Bean\n\tpublic WelcomePageHandlerMapping welcomePageHandlerMapping(\n\t\t\tResourceProperties resourceProperties) &#123;\n\t\treturn new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),\n\t\t\t\tthis.mvcProperties.getStaticPathPattern());\n\t&#125;\n\n      &#x2F;&#x2F;配置喜欢的图标\n\t@Configuration\n\t@ConditionalOnProperty(value &#x3D; &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing &#x3D; true)\n\tpublic static class FaviconConfiguration &#123;\n\n\t\tprivate final ResourceProperties resourceProperties;\n\n\t\tpublic FaviconConfiguration(ResourceProperties resourceProperties) &#123;\n\t\t\tthis.resourceProperties &#x3D; resourceProperties;\n\t\t&#125;\n\n\t\t@Bean\n\t\tpublic SimpleUrlHandlerMapping faviconHandlerMapping() &#123;\n\t\t\tSimpleUrlHandlerMapping mapping &#x3D; new SimpleUrlHandlerMapping();\n\t\t\tmapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);\n             \t&#x2F;&#x2F;所有  **&#x2F;favicon.ico \n\t\t\tmapping.setUrlMap(Collections.singletonMap(&quot;**&#x2F;favicon.ico&quot;,\n\t\t\t\t\tfaviconRequestHandler()));\n\t\t\treturn mapping;\n\t\t&#125;\n\n\t\t@Bean\n\t\tpublic ResourceHttpRequestHandler faviconRequestHandler() &#123;\n\t\t\tResourceHttpRequestHandler requestHandler &#x3D; new ResourceHttpRequestHandler();\n\t\t\trequestHandler\n\t\t\t\t\t.setLocations(this.resourceProperties.getFaviconLocations());\n\t\t\treturn requestHandler;\n\t\t&#125;\n\n\t&#125;\n\n\n\n\n&#x3D;&#x3D;1）、所有 &#x2F;webjars&#x2F;** ，都去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找资源；&#x3D;&#x3D;\n​\twebjars：以jar包的方式引入静态资源；\nhttp://www.webjars.org/\n\nlocalhost:8080&#x2F;webjars&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.js\n&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;\n\t\t\t&lt;version&gt;3.3.1&lt;&#x2F;version&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\n\n\n&#x3D;&#x3D;2）、”&#x2F;**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射&#x3D;&#x3D;\n&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, \n&quot;classpath:&#x2F;resources&#x2F;&quot;,\n&quot;classpath:&#x2F;static&#x2F;&quot;, \n&quot;classpath:&#x2F;public&#x2F;&quot; \n&quot;&#x2F;&quot;：当前项目的根路径\n\nlocalhost:8080&#x2F;abc &#x3D;&#x3D;&#x3D;  去静态资源文件夹里面找abc\n&#x3D;&#x3D;3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”&#x2F;**”映射；&#x3D;&#x3D;\n​\tlocalhost:8080&#x2F;   找index页面\n&#x3D;&#x3D;4）、所有的 **&#x2F;favicon.ico  都是在静态资源文件下找；&#x3D;&#x3D;\n3、模板引擎JSP、Velocity、Freemarker、Thymeleaf\n\nSpringBoot推荐的Thymeleaf；\n语法更简单，功能更强大；\n1、引入thymeleaf；\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n          \t2.1.6\n\t\t&lt;&#x2F;dependency&gt;\n切换thymeleaf版本\n&lt;properties&gt;\n\t\t&lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;&#x2F;thymeleaf.version&gt;\n\t\t&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;\n\t\t&lt;!-- thymeleaf2   layout1--&gt;\n\t\t&lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;&#x2F;thymeleaf-layout-dialect.version&gt;\n  &lt;&#x2F;properties&gt;\n\n\n\n2、Thymeleaf使用@ConfigurationProperties(prefix &#x3D; &quot;spring.thymeleaf&quot;)\npublic class ThymeleafProperties &#123;\n\n\tprivate static final Charset DEFAULT_ENCODING &#x3D; Charset.forName(&quot;UTF-8&quot;);\n\n\tprivate static final MimeType DEFAULT_CONTENT_TYPE &#x3D; MimeType.valueOf(&quot;text&#x2F;html&quot;);\n\n\tpublic static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n\n\tpublic static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;\n  \t&#x2F;&#x2F;\n\n只要我们把HTML页面放在classpath:&#x2F;templates&#x2F;，thymeleaf就能自动渲染；\n使用：\n1、导入thymeleaf的名称空间\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n\n2、使用thymeleaf语法；\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;h1&gt;成功！&lt;&#x2F;h1&gt;\n    &lt;!--th:text 将div里面的文本内容设置为 --&gt;\n    &lt;div th:text&#x3D;&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3、语法规则1）、th:text；改变当前元素里面的文本内容；\n​\tth：任意html属性；来替换原生属性的值\n\n2）、表达式？\nSimple expressions:（表达式语法）\n    Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；\n    \t\t1）、获取对象的属性、调用方法\n    \t\t2）、使用内置的基本对象：\n    \t\t\t#ctx : the context object.\n    \t\t\t#vars: the context variables.\n                #locale : the context locale.\n                #request : (only in Web Contexts) the HttpServletRequest object.\n                #response : (only in Web Contexts) the HttpServletResponse object.\n                #session : (only in Web Contexts) the HttpSession object.\n                #servletContext : (only in Web Contexts) the ServletContext object.\n                \n                $&#123;session.foo&#125;\n            3）、内置的一些工具对象：\n#execInfo : information about the template being processed.\n#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.\n#uris : methods for escaping parts of URLs&#x2F;URIs\n#conversions : methods for executing the configured conversion service (if any).\n#dates : methods for java.util.Date objects: formatting, component extraction, etc.\n#calendars : analogous to #dates , but for java.util.Calendar objects.\n#numbers : methods for formatting numeric objects.\n#strings : methods for String objects: contains, startsWith, prepending&#x2F;appending, etc.\n#objects : methods for objects in general.\n#bools : methods for boolean evaluation.\n#arrays : methods for arrays.\n#lists : methods for lists.\n#sets : methods for sets.\n#maps : methods for maps.\n#aggregates : methods for creating aggregates on arrays or collections.\n#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).\n\n    Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；\n    \t补充：配合 th:object&#x3D;&quot;$&#123;session.user&#125;：\n   &lt;div th:object&#x3D;&quot;$&#123;session.user&#125;&quot;&gt;\n    &lt;p&gt;Name: &lt;span th:text&#x3D;&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;&#x2F;span&gt;.&lt;&#x2F;p&gt;\n    &lt;p&gt;Surname: &lt;span th:text&#x3D;&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;&#x2F;span&gt;.&lt;&#x2F;p&gt;\n    &lt;p&gt;Nationality: &lt;span th:text&#x3D;&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;&#x2F;span&gt;.&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n    \n    Message Expressions: #&#123;...&#125;：获取国际化内容\n    Link URL Expressions: @&#123;...&#125;：定义URL；\n    \t\t@&#123;&#x2F;order&#x2F;process(execId&#x3D;$&#123;execId&#125;,execType&#x3D;&#39;FAST&#39;)&#125;\n    Fragment Expressions: ~&#123;...&#125;：片段引用表达式\n    \t\t&lt;div th:insert&#x3D;&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;&#x2F;div&gt;\n    \t\t\nLiterals（字面量）\n      Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,…\n      Number literals: 0 , 34 , 3.0 , 12.3 ,…\n      Boolean literals: true , false\n      Null literal: null\n      Literal tokens: one , sometext , main ,…\nText operations:（文本操作）\n    String concatenation: +\n    Literal substitutions: |The name is $&#123;name&#125;|\nArithmetic operations:（数学运算）\n    Binary operators: + , - , * , &#x2F; , %\n    Minus sign (unary operator): -\nBoolean operations:（布尔运算）\n    Binary operators: and , or\n    Boolean negation (unary operator): ! , not\nComparisons and equality:（比较运算）\n    Comparators: &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le )\n    Equality operators: &#x3D;&#x3D; , !&#x3D; ( eq , ne )\nConditional operators:条件运算（三元运算符）\n    If-then: (if) ? (then)\n    If-then-else: (if) ? (then) : (else)\n    Default: (value) ?: (defaultvalue)\nSpecial tokens:\n    No-Operation: _ \n\n4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications\n1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC\n以下是SpringBoot对SpringMVC的默认配置:&#x3D;&#x3D;（WebMvcAutoConfiguration）&#x3D;&#x3D;\n\nInclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.\n\n自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））\nContentNegotiatingViewResolver：组合所有的视图解析器的；\n&#x3D;&#x3D;如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；&#x3D;&#x3D;\n\n\nSupport for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars\n\nStatic index.html support. 静态首页访问\n\nCustom Favicon support (see below).  favicon.ico\n\n自动注册了 of Converter, GenericConverter, Formatter beans.\n\nConverter：转换器；  public String hello(User user)：类型转换使用Converter\nFormatter  格式化器；  2017.12.17&#x3D;&#x3D;&#x3D;Date；\n\n\n\n@Bean\n@ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc&quot;, name &#x3D; &quot;date-format&quot;)&#x2F;&#x2F;在文件中配置日期格式化的规则\npublic Formatter&lt;Date&gt; dateFormatter() &#123;\n\treturn new DateFormatter(this.mvcProperties.getDateFormat());&#x2F;&#x2F;日期格式化组件\n&#125;\n\n​\t&#x3D;&#x3D;自己添加的格式化器转换器，我们只需要放在容器中即可&#x3D;&#x3D;\n\nSupport for HttpMessageConverters (see below).\n\nHttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；\n\nHttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter；\n&#x3D;&#x3D;自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）&#x3D;&#x3D;\n\n\n\nAutomatic registration of MessageCodesResolver (see below).定义错误代码生成规则\n\nAutomatic use of a ConfigurableWebBindingInitializer bean (see below).\n&#x3D;&#x3D;我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）&#x3D;&#x3D;\n初始化WebDataBinder；\n请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean；\n\norg.springframework.boot.autoconfigure.web：web的所有自动场景；\nIf you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.\nIf you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.\n2、扩展SpringMVC&lt;mvc:view-controller path&#x3D;&quot;&#x2F;hello&quot; view-name&#x3D;&quot;success&quot;&#x2F;&gt;\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;hello&quot;&#x2F;&gt;\n        &lt;bean&gt;&lt;&#x2F;bean&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n\n&#x3D;&#x3D;编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc&#x3D;&#x3D;;\n既保留了所有的自动配置，也能用我们扩展的配置；\n&#x2F;&#x2F;使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123;\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n       &#x2F;&#x2F; super.addViewControllers(registry);\n        &#x2F;&#x2F;浏览器发送 &#x2F;atguigu 请求来到 success\n        registry.addViewController(&quot;&#x2F;atguigu&quot;).setViewName(&quot;success&quot;);\n    &#125;\n&#125;\n\n原理：\n​\t1）、WebMvcAutoConfiguration是SpringMVC的自动配置类\n​\t2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)\n   @Configuration\npublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123;\n     private final WebMvcConfigurerComposite configurers &#x3D; new WebMvcConfigurerComposite();\n\n &#x2F;&#x2F;从容器中获取所有的WebMvcConfigurer\n     @Autowired(required &#x3D; false)\n     public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;\n         if (!CollectionUtils.isEmpty(configurers)) &#123;\n             this.configurers.addWebMvcConfigurers(configurers);\n           \t&#x2F;&#x2F;一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  \n           \t@Override\n            &#x2F;&#x2F; public void addViewControllers(ViewControllerRegistry registry) &#123;\n             &#x2F;&#x2F;    for (WebMvcConfigurer delegate : this.delegates) &#123;\n              &#x2F;&#x2F;       delegate.addViewControllers(registry);\n              &#x2F;&#x2F;   &#125;\n             &#125;\n         &#125;\n&#125;\n\n​\t3）、容器中所有的WebMvcConfigurer都会一起起作用；\n​\t4）、我们的配置类也会被调用；\n​\t效果：SpringMVC的自动配置和我们的扩展配置都会起作用；\n3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了\n我们需要在配置类中添加@EnableWebMvc即可；\n&#x2F;&#x2F;使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@EnableWebMvc\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123;\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n       &#x2F;&#x2F; super.addViewControllers(registry);\n        &#x2F;&#x2F;浏览器发送 &#x2F;atguigu 请求来到 success\n        registry.addViewController(&quot;&#x2F;atguigu&quot;).setViewName(&quot;success&quot;);\n    &#125;\n&#125;\n\n原理：\n为什么@EnableWebMvc自动配置就失效了；\n1）@EnableWebMvc的核心\n@Import(DelegatingWebMvcConfiguration.class)\npublic @interface EnableWebMvc &#123;\n\n2）、\n@Configuration\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;\n\n3）、\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,\n\t\tWebMvcConfigurerAdapter.class &#125;)\n&#x2F;&#x2F;容器中没有这个组件的时候，这个自动配置类才生效\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,\n\t\tValidationAutoConfiguration.class &#125;)\npublic class WebMvcAutoConfiguration &#123;\n\n4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；\n5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；\n5、如何修改SpringBoot的默认配置模式：\n​\t1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；\n​\t2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置\n​\t3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置\n6、RestfulCRUD1）、默认访问首页\n&#x2F;&#x2F;使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n&#x2F;&#x2F;@EnableWebMvc   不要接管SpringMVC\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123;\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n       &#x2F;&#x2F; super.addViewControllers(registry);\n        &#x2F;&#x2F;浏览器发送 &#x2F;atguigu 请求来到 success\n        registry.addViewController(&quot;&#x2F;atguigu&quot;).setViewName(&quot;success&quot;);\n    &#125;\n\n    &#x2F;&#x2F;所有的WebMvcConfigurerAdapter组件都会一起起作用\n    @Bean &#x2F;&#x2F;将组件注册在容器\n    public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123;\n        WebMvcConfigurerAdapter adapter &#x3D; new WebMvcConfigurerAdapter() &#123;\n            @Override\n            public void addViewControllers(ViewControllerRegistry registry) &#123;\n                registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;login&quot;);\n                registry.addViewController(&quot;&#x2F;index.html&quot;).setViewName(&quot;login&quot;);\n            &#125;\n        &#125;;\n        return adapter;\n    &#125;\n&#125;\n\n\n2）、国际化1）、编写国际化配置文件；\n2）、使用ResourceBundleMessageSource管理国际化资源文件\n3）、在页面使用fmt:message取出国际化内容\n步骤：\n1）、编写国际化配置文件，抽取页面需要显示的国际化消息\n\n2）、SpringBoot自动配置好了管理国际化资源文件的组件；\n@ConfigurationProperties(prefix &#x3D; &quot;spring.messages&quot;)\npublic class MessageSourceAutoConfiguration &#123;\n    \n    &#x2F;**\n\t * Comma-separated list of basenames (essentially a fully-qualified classpath\n\t * location), each following the ResourceBundle convention with relaxed support for\n\t * slash based locations. If it doesn&#39;t contain a package qualifier (such as\n\t * &quot;org.mypackage&quot;), it will be resolved from the classpath root.\n\t *&#x2F;\n\tprivate String basename &#x3D; &quot;messages&quot;;  \n    &#x2F;&#x2F;我们的配置文件可以直接放在类路径下叫messages.properties；\n    \n    @Bean\n\tpublic MessageSource messageSource() &#123;\n\t\tResourceBundleMessageSource messageSource &#x3D; new ResourceBundleMessageSource();\n\t\tif (StringUtils.hasText(this.basename)) &#123;\n            &#x2F;&#x2F;设置国际化资源文件的基础名（去掉语言国家代码的）\n\t\t\tmessageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\tStringUtils.trimAllWhitespace(this.basename)));\n\t\t&#125;\n\t\tif (this.encoding !&#x3D; null) &#123;\n\t\t\tmessageSource.setDefaultEncoding(this.encoding.name());\n\t\t&#125;\n\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\tmessageSource.setCacheSeconds(this.cacheSeconds);\n\t\tmessageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);\n\t\treturn messageSource;\n\t&#125;\n\n\n\n3）、去页面获取国际化的值；\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;  xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n\t&lt;head&gt;\n\t\t&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;\n\t\t&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, shrink-to-fit&#x3D;no&quot;&gt;\n\t\t&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;&quot;&gt;\n\t\t&lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;&quot;&gt;\n\t\t&lt;title&gt;Signin Template for Bootstrap&lt;&#x2F;title&gt;\n\t\t&lt;!-- Bootstrap core CSS --&gt;\n\t\t&lt;link href&#x3D;&quot;asserts&#x2F;css&#x2F;bootstrap.min.css&quot; th:href&#x3D;&quot;@&#123;&#x2F;webjars&#x2F;bootstrap&#x2F;4.0.0&#x2F;css&#x2F;bootstrap.css&#125;&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n\t\t&lt;!-- Custom styles for this template --&gt;\n\t\t&lt;link href&#x3D;&quot;asserts&#x2F;css&#x2F;signin.css&quot; th:href&#x3D;&quot;@&#123;&#x2F;asserts&#x2F;css&#x2F;signin.css&#125;&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\n\t&lt;body class&#x3D;&quot;text-center&quot;&gt;\n\t\t&lt;form class&#x3D;&quot;form-signin&quot; action&#x3D;&quot;dashboard.html&quot;&gt;\n\t\t\t&lt;img class&#x3D;&quot;mb-4&quot; th:src&#x3D;&quot;@&#123;&#x2F;asserts&#x2F;img&#x2F;bootstrap-solid.svg&#125;&quot; src&#x3D;&quot;asserts&#x2F;img&#x2F;bootstrap-solid.svg&quot; alt&#x3D;&quot;&quot; width&#x3D;&quot;72&quot; height&#x3D;&quot;72&quot;&gt;\n\t\t\t&lt;h1 class&#x3D;&quot;h3 mb-3 font-weight-normal&quot; th:text&#x3D;&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;&#x2F;h1&gt;\n\t\t\t&lt;label class&#x3D;&quot;sr-only&quot; th:text&#x3D;&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;&#x2F;label&gt;\n\t\t\t&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;Username&quot; th:placeholder&#x3D;&quot;#&#123;login.username&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;\n\t\t\t&lt;label class&#x3D;&quot;sr-only&quot; th:text&#x3D;&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;&#x2F;label&gt;\n\t\t\t&lt;input type&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;Password&quot; th:placeholder&#x3D;&quot;#&#123;login.password&#125;&quot; required&#x3D;&quot;&quot;&gt;\n\t\t\t&lt;div class&#x3D;&quot;checkbox mb-3&quot;&gt;\n\t\t\t\t&lt;label&gt;\n          \t\t&lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;remember-me&quot;&#x2F;&gt; [[#&#123;login.remember&#125;]]\n        &lt;&#x2F;label&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;button class&#x3D;&quot;btn btn-lg btn-primary btn-block&quot; type&#x3D;&quot;submit&quot; th:text&#x3D;&quot;#&#123;login.btn&#125;&quot;&gt;Sign in&lt;&#x2F;button&gt;\n\t\t\t&lt;p class&#x3D;&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;&#x2F;p&gt;\n\t\t\t&lt;a class&#x3D;&quot;btn btn-sm&quot;&gt;中文&lt;&#x2F;a&gt;\n\t\t\t&lt;a class&#x3D;&quot;btn btn-sm&quot;&gt;English&lt;&#x2F;a&gt;\n\t\t&lt;&#x2F;form&gt;\n\n\t&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n效果：根据浏览器语言设置的信息切换了国际化；\n原理：\n​\t国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\t@ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc&quot;, name &#x3D; &quot;locale&quot;)\n\t\tpublic LocaleResolver localeResolver() &#123;\n\t\t\tif (this.mvcProperties\n\t\t\t\t\t.getLocaleResolver() &#x3D;&#x3D; WebMvcProperties.LocaleResolver.FIXED) &#123;\n\t\t\t\treturn new FixedLocaleResolver(this.mvcProperties.getLocale());\n\t\t\t&#125;\n\t\t\tAcceptHeaderLocaleResolver localeResolver &#x3D; new AcceptHeaderLocaleResolver();\n\t\t\tlocaleResolver.setDefaultLocale(this.mvcProperties.getLocale());\n\t\t\treturn localeResolver;\n\t\t&#125;\n默认的就是根据请求头带来的区域信息获取Locale进行国际化\n\n4）、点击链接切换国际化\n&#x2F;**\n * 可以在连接上携带区域信息\n *&#x2F;\npublic class MyLocaleResolver implements LocaleResolver &#123;\n    \n    @Override\n    public Locale resolveLocale(HttpServletRequest request) &#123;\n        String l &#x3D; request.getParameter(&quot;l&quot;);\n        Locale locale &#x3D; Locale.getDefault();\n        if(!StringUtils.isEmpty(l))&#123;\n            String[] split &#x3D; l.split(&quot;_&quot;);\n            locale &#x3D; new Locale(split[0],split[1]);\n        &#125;\n        return locale;\n    &#125;\n\n    @Override\n    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;\n\n    &#125;\n&#125;\n\n\n @Bean\n    public LocaleResolver localeResolver()&#123;\n        return new MyLocaleResolver();\n    &#125;\n&#125;\n\n\n\n3）、登陆开发期间模板引擎页面修改以后，要实时生效\n1）、禁用模板引擎的缓存\n# 禁用缓存\nspring.thymeleaf.cache&#x3D;false \n\n2）、页面修改完成以后ctrl+f9：重新编译；\n登陆错误消息的显示\n&lt;p style&#x3D;&quot;color: red&quot; th:text&#x3D;&quot;$&#123;msg&#125;&quot; th:if&#x3D;&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n\n\n4）、拦截器进行登陆检查拦截器\n\n&#x2F;**\n * 登陆检查，\n *&#x2F;\npublic class LoginHandlerInterceptor implements HandlerInterceptor &#123;\n    &#x2F;&#x2F;目标方法执行之前\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        Object user &#x3D; request.getSession().getAttribute(&quot;loginUser&quot;);\n        if(user &#x3D;&#x3D; null)&#123;\n            &#x2F;&#x2F;未登陆，返回登陆页面\n            request.setAttribute(&quot;msg&quot;,&quot;没有权限请先登陆&quot;);\n            request.getRequestDispatcher(&quot;&#x2F;index.html&quot;).forward(request,response);\n            return false;\n        &#125;else&#123;\n            &#x2F;&#x2F;已登陆，放行请求\n            return true;\n        &#125;\n\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n\n    &#125;\n&#125;\n\n\n\n\n注册拦截器\n&#x2F;&#x2F;所有的WebMvcConfigurerAdapter组件都会一起起作用\n  @Bean &#x2F;&#x2F;将组件注册在容器\n  public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123;\n      WebMvcConfigurerAdapter adapter &#x3D; new WebMvcConfigurerAdapter() &#123;\n          @Override\n          public void addViewControllers(ViewControllerRegistry registry) &#123;\n              registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;login&quot;);\n              registry.addViewController(&quot;&#x2F;index.html&quot;).setViewName(&quot;login&quot;);\n              registry.addViewController(&quot;&#x2F;main.html&quot;).setViewName(&quot;dashboard&quot;);\n          &#125;\n\n          &#x2F;&#x2F;注册拦截器\n          @Override\n          public void addInterceptors(InterceptorRegistry registry) &#123;\n              &#x2F;&#x2F;super.addInterceptors(registry);\n              &#x2F;&#x2F;静态资源；  *.css , *.js\n              &#x2F;&#x2F;SpringBoot已经做好了静态资源映射\n              registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;)\n                      .excludePathPatterns(&quot;&#x2F;index.html&quot;,&quot;&#x2F;&quot;,&quot;&#x2F;user&#x2F;login&quot;);\n          &#125;\n      &#125;;\n      return adapter;\n  &#125;\n\n5）、CRUD-员工列表实验要求：\n1）、RestfulCRUD：CRUD满足Rest风格；\nURI：  &#x2F;资源名称&#x2F;资源标识       HTTP请求方式区分对资源CRUD操作\n\n\n\n\n普通CRUD（uri来区分操作）\nRestfulCRUD\n\n\n\n查询\ngetEmp\nemp—GET\n\n\n添加\naddEmp?xxx\nemp—POST\n\n\n修改\nupdateEmp?id&#x3D;xxx&amp;xxx&#x3D;xx\nemp&#x2F;{id}—PUT\n\n\n删除\ndeleteEmp?id&#x3D;1\nemp&#x2F;{id}—DELETE\n\n\n2）、实验的请求架构;\n\n\n\n实验功能\n请求URI\n请求方式\n\n\n\n查询所有员工\nemps\nGET\n\n\n查询某个员工(来到修改页面)\nemp&#x2F;1\nGET\n\n\n来到添加页面\nemp\nGET\n\n\n添加员工\nemp\nPOST\n\n\n来到修改页面（查出员工进行信息回显）\nemp&#x2F;1\nGET\n\n\n修改员工\nemp\nPUT\n\n\n删除员工\nemp&#x2F;1\nDELETE\n\n\n3）、员工列表：\nthymeleaf公共页面元素抽取1、抽取公共片段\n&lt;div th:fragment&#x3D;&quot;copy&quot;&gt;\n&amp;copy; 2011 The Good Thymes Virtual Grocery\n&lt;&#x2F;div&gt;\n\n2、引入公共片段\n&lt;div th:insert&#x3D;&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;&#x2F;div&gt;\n~&#123;templatename::selector&#125;：模板名::选择器\n~&#123;templatename::fragmentname&#125;:模板名::片段名\n\n3、默认效果：\ninsert的公共片段在div标签中\n如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：\n行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；\n\n\n\n三种引入公共片段的th属性：\nth:insert：将公共片段整个插入到声明引入的元素中\nth:replace：将声明引入的元素替换为公共片段\nth:include：将被引入的片段的内容包含进这个标签中\n&lt;footer th:fragment&#x3D;&quot;copy&quot;&gt;\n&amp;copy; 2011 The Good Thymes Virtual Grocery\n&lt;&#x2F;footer&gt;\n\n引入方式\n&lt;div th:insert&#x3D;&quot;footer :: copy&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div th:replace&#x3D;&quot;footer :: copy&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div th:include&#x3D;&quot;footer :: copy&quot;&gt;&lt;&#x2F;div&gt;\n\n效果\n&lt;div&gt;\n    &lt;footer&gt;\n    &amp;copy; 2011 The Good Thymes Virtual Grocery\n    &lt;&#x2F;footer&gt;\n&lt;&#x2F;div&gt;\n\n&lt;footer&gt;\n&amp;copy; 2011 The Good Thymes Virtual Grocery\n&lt;&#x2F;footer&gt;\n\n&lt;div&gt;\n&amp;copy; 2011 The Good Thymes Virtual Grocery\n&lt;&#x2F;div&gt;\n\n\n\n引入片段的时候传入参数： \n\n&lt;nav class&#x3D;&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id&#x3D;&quot;sidebar&quot;&gt;\n    &lt;div class&#x3D;&quot;sidebar-sticky&quot;&gt;\n        &lt;ul class&#x3D;&quot;nav flex-column&quot;&gt;\n            &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n                &lt;a class&#x3D;&quot;nav-link active&quot;\n                   th:class&#x3D;&quot;$&#123;activeUri&#x3D;&#x3D;&#39;main.html&#39;?&#39;nav-link active&#39;:&#39;nav-link&#39;&#125;&quot;\n                   href&#x3D;&quot;#&quot; th:href&#x3D;&quot;@&#123;&#x2F;main.html&#125;&quot;&gt;\n                    &lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; width&#x3D;&quot;24&quot; height&#x3D;&quot;24&quot; viewBox&#x3D;&quot;0 0 24 24&quot; fill&#x3D;&quot;none&quot; stroke&#x3D;&quot;currentColor&quot; stroke-width&#x3D;&quot;2&quot; stroke-linecap&#x3D;&quot;round&quot; stroke-linejoin&#x3D;&quot;round&quot; class&#x3D;&quot;feather feather-home&quot;&gt;\n                        &lt;path d&#x3D;&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;&#x2F;path&gt;\n                        &lt;polyline points&#x3D;&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;&#x2F;polyline&gt;\n                    &lt;&#x2F;svg&gt;\n                    Dashboard &lt;span class&#x3D;&quot;sr-only&quot;&gt;(current)&lt;&#x2F;span&gt;\n                &lt;&#x2F;a&gt;\n            &lt;&#x2F;li&gt;\n\n&lt;!--引入侧边栏;传入参数--&gt;\n&lt;div th:replace&#x3D;&quot;commons&#x2F;bar::#sidebar(activeUri&#x3D;&#39;emps&#39;)&quot;&gt;&lt;&#x2F;div&gt;\n\n6）、CRUD-员工添加添加页面\n&lt;form&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;LastName&lt;&#x2F;label&gt;\n        &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;zhangsan&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;Email&lt;&#x2F;label&gt;\n        &lt;input type&#x3D;&quot;email&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;zhangsan@atguigu.com&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;Gender&lt;&#x2F;label&gt;&lt;br&#x2F;&gt;\n        &lt;div class&#x3D;&quot;form-check form-check-inline&quot;&gt;\n            &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot;  value&#x3D;&quot;1&quot;&gt;\n            &lt;label class&#x3D;&quot;form-check-label&quot;&gt;男&lt;&#x2F;label&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-check form-check-inline&quot;&gt;\n            &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot;  value&#x3D;&quot;0&quot;&gt;\n            &lt;label class&#x3D;&quot;form-check-label&quot;&gt;女&lt;&#x2F;label&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;department&lt;&#x2F;label&gt;\n        &lt;select class&#x3D;&quot;form-control&quot;&gt;\n            &lt;option&gt;1&lt;&#x2F;option&gt;\n            &lt;option&gt;2&lt;&#x2F;option&gt;\n            &lt;option&gt;3&lt;&#x2F;option&gt;\n            &lt;option&gt;4&lt;&#x2F;option&gt;\n            &lt;option&gt;5&lt;&#x2F;option&gt;\n        &lt;&#x2F;select&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;Birth&lt;&#x2F;label&gt;\n        &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;zhangsan&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;添加&lt;&#x2F;button&gt;\n&lt;&#x2F;form&gt;\n\n提交的数据格式不对：生日：日期；\n2017-12-12；2017&#x2F;12&#x2F;12；2017.12.12；\n日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;\n2017-12-12—Date； 类型转换，格式化;\n默认日期是按照&#x2F;的方式；\n7）、CRUD-员工修改修改添加二合一表单\n&lt;!--需要区分是员工修改还是添加；--&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;emp&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;!--发送put请求修改员工数据--&gt;\n    &lt;!--\n1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）\n2、页面创建一个post表单\n3、创建一个input项，name&#x3D;&quot;_method&quot;;值就是我们指定的请求方式\n--&gt;\n    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;put&quot; th:if&#x3D;&quot;$&#123;emp!&#x3D;null&#125;&quot;&#x2F;&gt;\n    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;id&quot; th:if&#x3D;&quot;$&#123;emp!&#x3D;null&#125;&quot; th:value&#x3D;&quot;$&#123;emp.id&#125;&quot;&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;LastName&lt;&#x2F;label&gt;\n        &lt;input name&#x3D;&quot;lastName&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;zhangsan&quot; th:value&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?$&#123;emp.lastName&#125;&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;Email&lt;&#x2F;label&gt;\n        &lt;input name&#x3D;&quot;email&quot; type&#x3D;&quot;email&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;zhangsan@atguigu.com&quot; th:value&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?$&#123;emp.email&#125;&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;Gender&lt;&#x2F;label&gt;&lt;br&#x2F;&gt;\n        &lt;div class&#x3D;&quot;form-check form-check-inline&quot;&gt;\n            &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;1&quot; th:checked&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?$&#123;emp.gender&#x3D;&#x3D;1&#125;&quot;&gt;\n            &lt;label class&#x3D;&quot;form-check-label&quot;&gt;男&lt;&#x2F;label&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-check form-check-inline&quot;&gt;\n            &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;0&quot; th:checked&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?$&#123;emp.gender&#x3D;&#x3D;0&#125;&quot;&gt;\n            &lt;label class&#x3D;&quot;form-check-label&quot;&gt;女&lt;&#x2F;label&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;department&lt;&#x2F;label&gt;\n        &lt;!--提交的是部门的id--&gt;\n        &lt;select class&#x3D;&quot;form-control&quot; name&#x3D;&quot;department.id&quot;&gt;\n            &lt;option th:selected&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?$&#123;dept.id &#x3D;&#x3D; emp.department.id&#125;&quot; th:value&#x3D;&quot;$&#123;dept.id&#125;&quot; th:each&#x3D;&quot;dept:$&#123;depts&#125;&quot; th:text&#x3D;&quot;$&#123;dept.departmentName&#125;&quot;&gt;1&lt;&#x2F;option&gt;\n        &lt;&#x2F;select&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;form-group&quot;&gt;\n        &lt;label&gt;Birth&lt;&#x2F;label&gt;\n        &lt;input name&#x3D;&quot;birth&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;zhangsan&quot; th:value&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?$&#123;#dates.format(emp.birth, &#39;yyyy-MM-dd HH:mm&#39;)&#125;&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary&quot; th:text&#x3D;&quot;$&#123;emp!&#x3D;null&#125;?&#39;修改&#39;:&#39;添加&#39;&quot;&gt;添加&lt;&#x2F;button&gt;\n&lt;&#x2F;form&gt;\n\n8）、CRUD-员工删除&lt;tr th:each&#x3D;&quot;emp:$&#123;emps&#125;&quot;&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.id&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.email&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.gender&#125;&#x3D;&#x3D;0?&#39;女&#39;:&#39;男&#39;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.department.departmentName&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;#dates.format(emp.birth, &#39;yyyy-MM-dd HH:mm&#39;)&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td&gt;\n        &lt;a class&#x3D;&quot;btn btn-sm btn-primary&quot; th:href&#x3D;&quot;@&#123;&#x2F;emp&#x2F;&#125;+$&#123;emp.id&#125;&quot;&gt;编辑&lt;&#x2F;a&gt;\n        &lt;button th:attr&#x3D;&quot;del_uri&#x3D;@&#123;&#x2F;emp&#x2F;&#125;+$&#123;emp.id&#125;&quot; class&#x3D;&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;删除&lt;&#x2F;button&gt;\n    &lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n\n\n&lt;script&gt;\n    $(&quot;.deleteBtn&quot;).click(function()&#123;\n        &#x2F;&#x2F;删除当前员工的\n        $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;,$(this).attr(&quot;del_uri&quot;)).submit();\n        return false;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n\n\n7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果：\n​\t\t1）、浏览器，返回一个默认的错误页面\n\n  浏览器发送请求的请求头：\n\n​\t\t2）、如果是其他客户端，默认响应一个json数据\n\n​\t\t\n原理：\n​\t可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；\n  给容器中添加了以下组件\n\n​\t1、DefaultErrorAttributes：\n帮我们在页面共享信息；\n@Override\n\tpublic Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,\n\t\t\tboolean includeStackTrace) &#123;\n\t\tMap&lt;String, Object&gt; errorAttributes &#x3D; new LinkedHashMap&lt;String, Object&gt;();\n\t\terrorAttributes.put(&quot;timestamp&quot;, new Date());\n\t\taddStatus(errorAttributes, requestAttributes);\n\t\taddErrorDetails(errorAttributes, requestAttributes, includeStackTrace);\n\t\taddPath(errorAttributes, requestAttributes);\n\t\treturn errorAttributes;\n\t&#125;\n\n\n\n​\t2、BasicErrorController：处理默认&#x2F;error请求\n@Controller\n@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:&#x2F;error&#125;&#125;&quot;)\npublic class BasicErrorController extends AbstractErrorController &#123;\n    \n    @RequestMapping(produces &#x3D; &quot;text&#x2F;html&quot;)&#x2F;&#x2F;产生html类型的数据；浏览器发送的请求来到这个方法处理\n\tpublic ModelAndView errorHtml(HttpServletRequest request,\n\t\t\tHttpServletResponse response) &#123;\n\t\tHttpStatus status &#x3D; getStatus(request);\n\t\tMap&lt;String, Object&gt; model &#x3D; Collections.unmodifiableMap(getErrorAttributes(\n\t\t\t\trequest, isIncludeStackTrace(request, MediaType.TEXT_HTML)));\n\t\tresponse.setStatus(status.value());\n        \n        &#x2F;&#x2F;去哪个页面作为错误页面；包含页面地址和页面内容\n\t\tModelAndView modelAndView &#x3D; resolveErrorView(request, response, status, model);\n\t\treturn (modelAndView &#x3D;&#x3D; null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);\n\t&#125;\n\n\t@RequestMapping\n\t@ResponseBody    &#x2F;&#x2F;产生json数据，其他客户端来到这个方法处理；\n\tpublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;\n\t\tMap&lt;String, Object&gt; body &#x3D; getErrorAttributes(request,\n\t\t\t\tisIncludeStackTrace(request, MediaType.ALL));\n\t\tHttpStatus status &#x3D; getStatus(request);\n\t\treturn new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);\n\t&#125;\n\n\n\n​\t3、ErrorPageCustomizer：\n@Value(&quot;$&#123;error.path:&#x2F;error&#125;&quot;)\nprivate String path &#x3D; &quot;&#x2F;error&quot;;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）\n\n\n\n​\t4、DefaultErrorViewResolver：\n@Override\n\tpublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,\n\t\t\tMap&lt;String, Object&gt; model) &#123;\n\t\tModelAndView modelAndView &#x3D; resolve(String.valueOf(status), model);\n\t\tif (modelAndView &#x3D;&#x3D; null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;\n\t\t\tmodelAndView &#x3D; resolve(SERIES_VIEWS.get(status.series()), model);\n\t\t&#125;\n\t\treturn modelAndView;\n\t&#125;\n\n\tprivate ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123;\n        &#x2F;&#x2F;默认SpringBoot可以去找到一个页面？  error&#x2F;404\n\t\tString errorViewName &#x3D; &quot;error&#x2F;&quot; + viewName;\n        \n        &#x2F;&#x2F;模板引擎可以解析这个页面地址就用模板引擎解析\n\t\tTemplateAvailabilityProvider provider &#x3D; this.templateAvailabilityProviders\n\t\t\t\t.getProvider(errorViewName, this.applicationContext);\n\t\tif (provider !&#x3D; null) &#123;\n            &#x2F;&#x2F;模板引擎可用的情况下返回到errorViewName指定的视图地址\n\t\t\treturn new ModelAndView(errorViewName, model);\n\t\t&#125;\n        &#x2F;&#x2F;模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error&#x2F;404.html\n\t\treturn resolveResource(errorViewName, model);\n\t&#125;\n\n\n\n​\t步骤：\n​\t\t一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到&#x2F;error请求；就会被BasicErrorController处理；\n​\t\t1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的；\nprotected ModelAndView resolveErrorView(HttpServletRequest request,\n      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123;\n    &#x2F;&#x2F;所有的ErrorViewResolver得到ModelAndView\n   for (ErrorViewResolver resolver : this.errorViewResolvers) &#123;\n      ModelAndView modelAndView &#x3D; resolver.resolveErrorView(request, status, model);\n      if (modelAndView !&#x3D; null) &#123;\n         return modelAndView;\n      &#125;\n   &#125;\n   return null;\n&#125;\n\n2）、如果定制错误响应：1）、如何定制错误的页面；​\t\t\t1）、有模板引擎的情况下；error&#x2F;状态码; 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；\n​\t\t\t我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；\t\t\n​\t\t\t页面能获取的信息；\n​\t\t\t\ttimestamp：时间戳\n​\t\t\t\tstatus：状态码\n​\t\t\t\terror：错误提示\n​\t\t\t\texception：异常对象\n​\t\t\t\tmessage：异常消息\n​\t\t\t\terrors：JSR303数据校验的错误都在这里\n​\t\t\t2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；\n​\t\t\t3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；\n2）、如何定制错误的json数据；​\t\t1）、自定义异常处理&amp;返回定制json数据；\n@ControllerAdvice\npublic class MyExceptionHandler &#123;\n\n    @ResponseBody\n    @ExceptionHandler(UserNotExistException.class)\n    public Map&lt;String,Object&gt; handleException(Exception e)&#123;\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;code&quot;,&quot;user.notexist&quot;);\n        map.put(&quot;message&quot;,e.getMessage());\n        return map;\n    &#125;\n&#125;\n&#x2F;&#x2F;没有自适应效果...\n\n\n\n​\t\t2）、转发到&#x2F;error进行自适应响应效果处理\n@ExceptionHandler(UserNotExistException.class)\n   public String handleException(Exception e, HttpServletRequest request)&#123;\n       Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n       &#x2F;&#x2F;传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程\n       &#x2F;**\n        * Integer statusCode &#x3D; (Integer) request\n        .getAttribute(&quot;javax.servlet.error.status_code&quot;);\n        *&#x2F;\n       request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);\n       map.put(&quot;code&quot;,&quot;user.notexist&quot;);\n       map.put(&quot;message&quot;,e.getMessage());\n       &#x2F;&#x2F;转发到&#x2F;error\n       return &quot;forward:&#x2F;error&quot;;\n   &#125;\n\n3）、将我们的定制数据携带出去；出现错误以后，会来到&#x2F;error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；\n​\t1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；\n​\t2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；\n​\t\t\t容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；\n自定义ErrorAttributes\n&#x2F;&#x2F;给容器中加入我们自己定义的ErrorAttributes\n@Component\npublic class MyErrorAttributes extends DefaultErrorAttributes &#123;\n\n    @Override\n    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123;\n        Map&lt;String, Object&gt; map &#x3D; super.getErrorAttributes(requestAttributes, includeStackTrace);\n        map.put(&quot;company&quot;,&quot;atguigu&quot;);\n        return map;\n    &#125;\n&#125;\n\n最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，\n\n8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；\n\n问题？\n1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；\nserver.port&#x3D;8081\nserver.context-path&#x3D;&#x2F;crud\n\nserver.tomcat.uri-encoding&#x3D;UTF-8\n\n&#x2F;&#x2F;通用的Servlet容器设置\nserver.xxx\n&#x2F;&#x2F;Tomcat的设置\nserver.tomcat.xxx\n\n2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置\n@Bean  &#x2F;&#x2F;一定要将这个定制器加入到容器中\npublic EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123;\n    return new EmbeddedServletContainerCustomizer() &#123;\n\n        &#x2F;&#x2F;定制嵌入式的Servlet容器相关的规则\n        @Override\n        public void customize(ConfigurableEmbeddedServletContainer container) &#123;\n            container.setPort(8083);\n        &#125;\n    &#125;;\n&#125;\n\n2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。\n注册三大组件用以下方式\nServletRegistrationBean\n&#x2F;&#x2F;注册三大组件\n@Bean\npublic ServletRegistrationBean myServlet()&#123;\n    ServletRegistrationBean registrationBean &#x3D; new ServletRegistrationBean(new MyServlet(),&quot;&#x2F;myServlet&quot;);\n    return registrationBean;\n&#125;\n\n\nFilterRegistrationBean\n@Bean\npublic FilterRegistrationBean myFilter()&#123;\n    FilterRegistrationBean registrationBean &#x3D; new FilterRegistrationBean();\n    registrationBean.setFilter(new MyFilter());\n    registrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;hello&quot;,&quot;&#x2F;myServlet&quot;));\n    return registrationBean;\n&#125;\n\nServletListenerRegistrationBean\n@Bean\npublic ServletListenerRegistrationBean myListener()&#123;\n    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean &#x3D; new ServletListenerRegistrationBean&lt;&gt;(new MyListener());\n    return registrationBean;\n&#125;\n\n\n\nSpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；\nDispatcherServletAutoConfiguration中：\n@Bean(name &#x3D; DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)\n@ConditionalOnBean(value &#x3D; DispatcherServlet.class, name &#x3D; DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\npublic ServletRegistrationBean dispatcherServletRegistration(\n      DispatcherServlet dispatcherServlet) &#123;\n   ServletRegistrationBean registration &#x3D; new ServletRegistrationBean(\n         dispatcherServlet, this.serverProperties.getServletMapping());\n    &#x2F;&#x2F;默认拦截： &#x2F;  所有请求；包静态资源，但是不拦截jsp请求；   &#x2F;*会拦截jsp\n    &#x2F;&#x2F;可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径\n    \n   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);\n   registration.setLoadOnStartup(\n         this.webMvcProperties.getServlet().getLoadOnStartup());\n   if (this.multipartConfig !&#x3D; null) &#123;\n      registration.setMultipartConfig(this.multipartConfig);\n   &#125;\n   return registration;\n&#125;\n\n\n2）、SpringBoot能不能支持其他的Servlet容器；\n3）、替换为其他嵌入式Servlet容器\n默认支持：\nTomcat（默认使用）\n&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；\n&lt;&#x2F;dependency&gt;\n\nJetty\n&lt;!-- 引入web模块 --&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n   &lt;exclusions&gt;\n      &lt;exclusion&gt;\n         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n         &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;&#x2F;exclusion&gt;\n   &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--引入其他的Servlet容器--&gt;\n&lt;dependency&gt;\n   &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n&lt;&#x2F;dependency&gt;\n\nUndertow\n&lt;!-- 引入web模块 --&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n   &lt;exclusions&gt;\n      &lt;exclusion&gt;\n         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n         &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;&#x2F;exclusion&gt;\n   &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--引入其他的Servlet容器--&gt;\n&lt;dependency&gt;\n   &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n&lt;&#x2F;dependency&gt;\n\n4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n@Configuration\n@ConditionalOnWebApplication\n@Import(BeanPostProcessorsRegistrar.class)\n&#x2F;&#x2F;导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件\n&#x2F;&#x2F;导入了EmbeddedServletContainerCustomizerBeanPostProcessor：\n&#x2F;&#x2F;后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作\npublic class EmbeddedServletContainerAutoConfiguration &#123;\n    \n    @Configuration\n\t@ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)&#x2F;&#x2F;判断当前是否引入了Tomcat依赖；\n\t@ConditionalOnMissingBean(value &#x3D; EmbeddedServletContainerFactory.class, search &#x3D; SearchStrategy.CURRENT)&#x2F;&#x2F;判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器\n\tpublic static class EmbeddedTomcat &#123;\n\n\t\t@Bean\n\t\tpublic TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123;\n\t\t\treturn new TomcatEmbeddedServletContainerFactory();\n\t\t&#125;\n\n\t&#125;\n    \n    &#x2F;**\n\t * Nested configuration if Jetty is being used.\n\t *&#x2F;\n\t@Configuration\n\t@ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class,\n\t\t\tWebAppContext.class &#125;)\n\t@ConditionalOnMissingBean(value &#x3D; EmbeddedServletContainerFactory.class, search &#x3D; SearchStrategy.CURRENT)\n\tpublic static class EmbeddedJetty &#123;\n\n\t\t@Bean\n\t\tpublic JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123;\n\t\t\treturn new JettyEmbeddedServletContainerFactory();\n\t\t&#125;\n\n\t&#125;\n\n\t&#x2F;**\n\t * Nested configuration if Undertow is being used.\n\t *&#x2F;\n\t@Configuration\n\t@ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)\n\t@ConditionalOnMissingBean(value &#x3D; EmbeddedServletContainerFactory.class, search &#x3D; SearchStrategy.CURRENT)\n\tpublic static class EmbeddedUndertow &#123;\n\n\t\t@Bean\n\t\tpublic UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123;\n\t\t\treturn new UndertowEmbeddedServletContainerFactory();\n\t\t&#125;\n\n\t&#125;\n\n1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）\npublic interface EmbeddedServletContainerFactory &#123;\n\n   &#x2F;&#x2F;获取嵌入式的Servlet容器\n   EmbeddedServletContainer getEmbeddedServletContainer(\n         ServletContextInitializer... initializers);\n\n&#125;\n\n\n2）、EmbeddedServletContainer：（嵌入式的Servlet容器）\n\n3）、以TomcatEmbeddedServletContainerFactory为例\n@Override\npublic EmbeddedServletContainer getEmbeddedServletContainer(\n      ServletContextInitializer... initializers) &#123;\n    &#x2F;&#x2F;创建一个Tomcat\n   Tomcat tomcat &#x3D; new Tomcat();\n    \n    &#x2F;&#x2F;配置Tomcat的基本环节\n   File baseDir &#x3D; (this.baseDirectory !&#x3D; null ? this.baseDirectory\n         : createTempDir(&quot;tomcat&quot;));\n   tomcat.setBaseDir(baseDir.getAbsolutePath());\n   Connector connector &#x3D; new Connector(this.protocol);\n   tomcat.getService().addConnector(connector);\n   customizeConnector(connector);\n   tomcat.setConnector(connector);\n   tomcat.getHost().setAutoDeploy(false);\n   configureEngine(tomcat.getEngine());\n   for (Connector additionalConnector : this.additionalTomcatConnectors) &#123;\n      tomcat.getService().addConnector(additionalConnector);\n   &#125;\n   prepareContext(tomcat.getHost(), initializers);\n    \n    &#x2F;&#x2F;将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器\n   return getTomcatEmbeddedServletContainer(tomcat);\n&#125;\n\n4）、我们对嵌入式容器的配置修改是怎么生效？\nServerProperties、EmbeddedServletContainerCustomizer\n\n\n\nEmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？\n怎么修改的原理？\n5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor\n&#x2F;&#x2F;初始化之前\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName)\n      throws BeansException &#123;\n    &#x2F;&#x2F;如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件\n   if (bean instanceof ConfigurableEmbeddedServletContainer) &#123;\n       &#x2F;&#x2F;\n      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);\n   &#125;\n   return bean;\n&#125;\n\nprivate void postProcessBeforeInitialization(\n\t\t\tConfigurableEmbeddedServletContainer bean) &#123;\n    &#x2F;&#x2F;获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；\n    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;\n        customizer.customize(bean);\n    &#125;\n&#125;\n\nprivate Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123;\n    if (this.customizers &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; Look up does not include the parent context\n        this.customizers &#x3D; new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(\n            this.beanFactory\n            &#x2F;&#x2F;从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer\n            &#x2F;&#x2F;定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件\n            .getBeansOfType(EmbeddedServletContainerCustomizer.class,\n                            false, false)\n            .values());\n        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);\n        this.customizers &#x3D; Collections.unmodifiableList(this.customizers);\n    &#125;\n    return this.customizers;\n&#125;\n\nServerProperties也是定制器\n\n步骤：\n1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】\n2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；\n只要是嵌入式的Servlet容器工厂，后置处理器就工作；\n3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法\n###5）、嵌入式Servlet容器启动原理；\n什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；\n获取嵌入式的Servlet容器工厂：\n1）、SpringBoot应用启动运行run方法\n2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext\n3）、refresh(context);刷新刚才创建好的ioc容器；\npublic void refresh() throws BeansException, IllegalStateException &#123;\n   synchronized (this.startupShutdownMonitor) &#123;\n      &#x2F;&#x2F; Prepare this context for refreshing.\n      prepareRefresh();\n\n      &#x2F;&#x2F; Tell the subclass to refresh the internal bean factory.\n      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();\n\n      &#x2F;&#x2F; Prepare the bean factory for use in this context.\n      prepareBeanFactory(beanFactory);\n\n      try &#123;\n         &#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         &#x2F;&#x2F; Invoke factory processors registered as beans in the context.\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         &#x2F;&#x2F; Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n\n         &#x2F;&#x2F; Initialize message source for this context.\n         initMessageSource();\n\n         &#x2F;&#x2F; Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n\n         &#x2F;&#x2F; Initialize other special beans in specific context subclasses.\n         onRefresh();\n\n         &#x2F;&#x2F; Check for listener beans and register them.\n         registerListeners();\n\n         &#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.\n         finishBeanFactoryInitialization(beanFactory);\n\n         &#x2F;&#x2F; Last step: publish corresponding event.\n         finishRefresh();\n      &#125;\n\n      catch (BeansException ex) &#123;\n         if (logger.isWarnEnabled()) &#123;\n            logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                  &quot;cancelling refresh attempt: &quot; + ex);\n         &#125;\n\n         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.\n         destroyBeans();\n\n         &#x2F;&#x2F; Reset &#39;active&#39; flag.\n         cancelRefresh(ex);\n\n         &#x2F;&#x2F; Propagate exception to caller.\n         throw ex;\n      &#125;\n\n      finally &#123;\n         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we\n         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      &#125;\n   &#125;\n&#125;\n\n4）、  onRefresh(); web的ioc容器重写了onRefresh方法\n5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer();\n6）、获取嵌入式的Servlet容器工厂：\nEmbeddedServletContainerFactory containerFactory &#x3D; getEmbeddedServletContainerFactory();\n​\t从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；\n7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer &#x3D; containerFactory      .getEmbeddedServletContainer(getSelfInitializer());\n8）、嵌入式的Servlet容器创建对象并启动Servlet容器；\n先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；\n&#x3D;&#x3D;IOC容器启动创建嵌入式的Servlet容器&#x3D;&#x3D;\n9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar\n​\t\t优点：简单、便携；\n​\t\t缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；\n外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；\n步骤1）、必须创建一个war项目；（利用idea创建好目录结构）\n2）、将嵌入式的Tomcat指定为provided；\n&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n   &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法\npublic class ServletInitializer extends SpringBootServletInitializer &#123;\n\n   @Override\n   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;\n       &#x2F;&#x2F;传入SpringBoot应用的主程序\n      return application.sources(SpringBoot04WebJspApplication.class);\n   &#125;\n\n&#125;\n\n4）、启动服务器就可以使用；\n原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；\nwar包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；\nservlet3.0（Spring注解版）：\n8.2.4 Shared libraries &#x2F; runtimes pluggability：\n规则：\n​\t1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：\n​\t2）、ServletContainerInitializer的实现放在jar包的META-INF&#x2F;services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名\n​\t3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；\n流程：\n1）、启动Tomcat\n2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer：\nSpring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer\n3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；\n4）、每一个WebApplicationInitializer都调用自己的onStartup；\n\n5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法\n6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器\nprotected WebApplicationContext createRootApplicationContext(\n      ServletContext servletContext) &#123;\n    &#x2F;&#x2F;1、创建SpringApplicationBuilder\n   SpringApplicationBuilder builder &#x3D; createSpringApplicationBuilder();\n   StandardServletEnvironment environment &#x3D; new StandardServletEnvironment();\n   environment.initPropertySources(servletContext, null);\n   builder.environment(environment);\n   builder.main(getClass());\n   ApplicationContext parent &#x3D; getExistingRootWebApplicationContext(servletContext);\n   if (parent !&#x3D; null) &#123;\n      this.logger.info(&quot;Root context already created (using as parent).&quot;);\n      servletContext.setAttribute(\n            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);\n      builder.initializers(new ParentContextApplicationContextInitializer(parent));\n   &#125;\n   builder.initializers(\n         new ServletContextApplicationContextInitializer(servletContext));\n   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);\n    \n    &#x2F;&#x2F;调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来\n   builder &#x3D; configure(builder);\n    \n    &#x2F;&#x2F;使用builder创建一个Spring应用\n   SpringApplication application &#x3D; builder.build();\n   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils\n         .findAnnotation(getClass(), Configuration.class) !&#x3D; null) &#123;\n      application.getSources().add(getClass());\n   &#125;\n   Assert.state(!application.getSources().isEmpty(),\n         &quot;No SpringApplication sources have been defined. Either override the &quot;\n               + &quot;configure method or add an @Configuration annotation&quot;);\n   &#x2F;&#x2F; Ensure error pages are registered\n   if (this.registerErrorPageFilter) &#123;\n      application.getSources().add(ErrorPageFilterConfiguration.class);\n   &#125;\n    &#x2F;&#x2F;启动Spring应用\n   return run(application);\n&#125;\n\n7）、Spring的应用就启动并且创建IOC容器\npublic ConfigurableApplicationContext run(String... args) &#123;\n   StopWatch stopWatch &#x3D; new StopWatch();\n   stopWatch.start();\n   ConfigurableApplicationContext context &#x3D; null;\n   FailureAnalyzers analyzers &#x3D; null;\n   configureHeadlessProperty();\n   SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);\n   listeners.starting();\n   try &#123;\n      ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(\n            args);\n      ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,\n            applicationArguments);\n      Banner printedBanner &#x3D; printBanner(environment);\n      context &#x3D; createApplicationContext();\n      analyzers &#x3D; new FailureAnalyzers(context);\n      prepareContext(context, environment, listeners, applicationArguments,\n            printedBanner);\n       \n       &#x2F;&#x2F;刷新IOC容器\n      refreshContext(context);\n      afterRefresh(context, applicationArguments);\n      listeners.finished(context, null);\n      stopWatch.stop();\n      if (this.logStartupInfo) &#123;\n         new StartupInfoLogger(this.mainApplicationClass)\n               .logStarted(getApplicationLog(), stopWatch);\n      &#125;\n      return context;\n   &#125;\n   catch (Throwable ex) &#123;\n      handleRunFailure(context, listeners, analyzers, ex);\n      throw new IllegalStateException(ex);\n   &#125;\n&#125;\n\n&#x3D;&#x3D;启动Servlet容器，再启动SpringBoot应用&#x3D;&#x3D;\n五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；\nDocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n运行中的这个镜像称为容器，容器启动是非常快速的。\n\n\n2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；\ndocker客户端(Client)：连接docker主机进行操作；\ndocker仓库(Registry)：用来保存各种打包好的软件镜像；\ndocker镜像(springboot)：软件打包好的镜像；放在docker仓库中；\ndocker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n\n使用Docker的步骤：\n1）、安装Docker\n2）、去Docker仓库找到这个软件对应的镜像；\n3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；\n4）、对容器的启动停止就是对软件的启动停止；\n3、安装Docker1）、安装linux虚拟机​\t1）、VMWare、VirtualBox（安装）；\n​\t2）、导入虚拟机文件centos7-atguigu.ova；\n​\t3）、双击启动linux虚拟机;使用  root&#x2F; 123456登陆\n​\t4）、使用客户端连接linux服务器进行命令操作；\n​\t5）、设置虚拟机网络；\n​\t\t桥接网络&#x3D;&#x3D;&#x3D;选好网卡&#x3D;&#x3D;&#x3D;&#x3D;接入网线；\n​\t6）、设置好网络以后使用命令重启虚拟机的网络\nservice network restart\n\n​\t7）、查看linux的ip地址\nip addr\n\n​\t8）、使用客户端连接linux；\n2）、在linux虚拟机上安装docker步骤：\n1、检查内核版本，必须是3.10及以上\nuname -r\n2、安装docker\nyum install docker\n3、输入y确认安装\n4、启动docker\n[root@localhost ~]# systemctl start docker\n[root@localhost ~]# docker -v\nDocker version 1.12.6, build 3e8e77d&#x2F;1.12.6\n5、开机启动docker\n[root@localhost ~]# systemctl enable docker\nCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;docker.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service.\n6、停止docker\nsystemctl stop docker\n\n4、Docker常用命令&amp;操作1）、镜像操作\n\n\n操作\n命令\n说明\n\n\n\n检索\ndocker  search 关键字  eg：docker  search redis\n我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。\n\n\n拉取\ndocker pull 镜像名:tag\n:tag是可选的，tag表示标签，多为软件的版本，默认是latest\n\n\n列表\ndocker springboot\n查看所有本地镜像\n\n\n删除\ndocker rmi image-id\n删除指定的本地镜像\n\n\nhttps://hub.docker.com/\n2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；\n步骤：\n1、搜索镜像\n[root@localhost ~]# docker search tomcat\n2、拉取镜像\n[root@localhost ~]# docker pull tomcat\n3、根据镜像启动容器\ndocker run --name mytomcat -d tomcat:latest\n4、docker ps  \n查看运行中的容器\n5、 停止运行中的容器\ndocker stop  容器的id\n6、查看所有的容器\ndocker ps -a\n7、启动容器\ndocker start 容器id\n8、删除一个容器\n docker rm 容器id\n9、启动一个做了端口映射的tomcat\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\n-d：后台运行\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\n\n10、为了演示简单关闭了linux的防火墙\nservice firewalld status ；查看防火墙状态\nservice firewalld stop：关闭防火墙\n11、查看容器的日志\ndocker logs container-name&#x2F;container-id\n\n更多命令参看\nhttps:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;docker&#x2F;\n可以参考每一个镜像的文档\n\n\n\n\n3）、安装MySQL示例docker pull mysql\n\n\n\n错误的启动\n[root@localhost ~]# docker run --name mysql01 -d mysql\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\n\nmysql退出了\n[root@localhost ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES\n42f09819908b        mysql               &quot;docker-entrypoint.sh&quot;   34 seconds ago      Exited (1) 33 seconds ago                            mysql01\n538bde63e500        tomcat              &quot;catalina.sh run&quot;        About an hour ago   Exited (143) About an hour ago                       compassionate_\ngoldstine\nc4f1ac60b3fc        tomcat              &quot;catalina.sh run&quot;        About an hour ago   Exited (143) About an hour ago                       lonely_fermi\n81ec743a5271        tomcat              &quot;catalina.sh run&quot;        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan\n\n\n&#x2F;&#x2F;错误日志\n[root@localhost ~]# docker logs 42f09819908b\nerror: database is uninitialized and password option is not specified \n  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个\n\n正确的启动\n[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\nb874c56bec49        mysql               &quot;docker-entrypoint.sh&quot;   4 seconds ago       Up 3 seconds        3306&#x2F;tcp            mysql01\n\n做了端口映射\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\nad10e4bc5c6a        mysql               &quot;docker-entrypoint.sh&quot;   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306&#x2F;tcp   mysql02\n\n\n\n几个其他的高级操作\ndocker run --name mysql03 -v &#x2F;conf&#x2F;mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag\n把主机的&#x2F;conf&#x2F;mysql文件夹挂载到 mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里面\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（&#x2F;conf&#x2F;mysql）\n\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci\n指定mysql的一些配置参数\n\n\n\n六、SpringBoot与数据访问1、JDBC&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n\t\t\t&lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\n\n\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql:&#x2F;&#x2F;192.168.15.22:3306&#x2F;jdbc\n    driver-class-name: com.mysql.jdbc.Driver\n\n效果：\n​\t默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；\n​\t数据源的相关配置都在DataSourceProperties里面；\n自动配置原理：\norg.springframework.boot.autoconfigure.jdbc：\n1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；\n2、SpringBoot默认可以支持；\norg.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、\n\n3、自定义数据源类型\n&#x2F;**\n * Generic DataSource configuration.\n *&#x2F;\n@ConditionalOnMissingBean(DataSource.class)\n@ConditionalOnProperty(name &#x3D; &quot;spring.datasource.type&quot;)\nstatic class Generic &#123;\n\n   @Bean\n   public DataSource dataSource(DataSourceProperties properties) &#123;\n       &#x2F;&#x2F;使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性\n      return properties.initializeDataSourceBuilder().build();\n   &#125;\n\n&#125;\n\n4、DataSourceInitializer：ApplicationListener；\n​\t作用：\n​\t\t1）、runSchemaScripts();运行建表语句；\n​\t\t2）、runDataScripts();运行插入数据的sql语句；\n默认只需要将文件命名为：\nschema-*.sql、data-*.sql\n默认规则：schema.sql，schema-all.sql；\n可以使用   \n\tschema:\n      - classpath:department.sql\n      指定位置\n\n5、操作数据库：自动配置了JdbcTemplate操作数据库\n2、整合Druid数据源导入druid数据源\n@Configuration\npublic class DruidConfig &#123;\n\n    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)\n    @Bean\n    public DataSource druid()&#123;\n       return  new DruidDataSource();\n    &#125;\n\n    &#x2F;&#x2F;配置Druid的监控\n    &#x2F;&#x2F;1、配置一个管理后台的Servlet\n    @Bean\n    public ServletRegistrationBean statViewServlet()&#123;\n        ServletRegistrationBean bean &#x3D; new ServletRegistrationBean(new StatViewServlet(), &quot;&#x2F;druid&#x2F;*&quot;);\n        Map&lt;String,String&gt; initParams &#x3D; new HashMap&lt;&gt;();\n\n        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);\n        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);\n        initParams.put(&quot;allow&quot;,&quot;&quot;);&#x2F;&#x2F;默认就是允许所有访问\n        initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);\n\n        bean.setInitParameters(initParams);\n        return bean;\n    &#125;\n\n\n    &#x2F;&#x2F;2、配置一个web监控的filter\n    @Bean\n    public FilterRegistrationBean webStatFilter()&#123;\n        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean();\n        bean.setFilter(new WebStatFilter());\n\n        Map&lt;String,String&gt; initParams &#x3D; new HashMap&lt;&gt;();\n        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,&#x2F;druid&#x2F;*&quot;);\n\n        bean.setInitParameters(initParams);\n\n        bean.setUrlPatterns(Arrays.asList(&quot;&#x2F;*&quot;));\n\n        return  bean;\n    &#125;\n&#125;\n\n\n3、整合MyBatis&lt;dependency&gt;\n\t&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n步骤：\n​\t1）、配置数据源相关属性（见上一节Druid）\n​\t2）、给数据库建表\n​\t3）、创建JavaBean\n4）、注解版&#x2F;&#x2F;指定这是一个操作数据库的mapper\n@Mapper\npublic interface DepartmentMapper &#123;\n\n    @Select(&quot;select * from department where id&#x3D;#&#123;id&#125;&quot;)\n    public Department getDeptById(Integer id);\n\n    @Delete(&quot;delete from department where id&#x3D;#&#123;id&#125;&quot;)\n    public int deleteDeptById(Integer id);\n\n    @Options(useGeneratedKeys &#x3D; true,keyProperty &#x3D; &quot;id&quot;)\n    @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;)\n    public int insertDept(Department department);\n\n    @Update(&quot;update department set departmentName&#x3D;#&#123;departmentName&#125; where id&#x3D;#&#123;id&#125;&quot;)\n    public int updateDept(Department department);\n&#125;\n\n问题：\n自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；\n@org.springframework.context.annotation.Configuration\npublic class MyBatisConfig &#123;\n\n    @Bean\n    public ConfigurationCustomizer configurationCustomizer()&#123;\n        return new ConfigurationCustomizer()&#123;\n\n            @Override\n            public void customize(Configuration configuration) &#123;\n                configuration.setMapUnderscoreToCamelCase(true);\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n\n\n使用MapperScan批量扫描所有的Mapper接口；\n@MapperScan(value &#x3D; &quot;com.atguigu.springboot.mapper&quot;)\n@SpringBootApplication\npublic class SpringBoot06DataMybatisApplication &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(SpringBoot06DataMybatisApplication.class, args);\n\t&#125;\n&#125;\n\n5）、配置文件版mybatis:\n  config-location: classpath:mybatis&#x2F;mybatis-config.xml 指定全局配置文件的位置\n  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml  指定sql映射文件的位置\n\n更多使用参照\nhttp://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\n4、整合SpringData JPA1）、SpringData简介\n2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）；\n1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；\n&#x2F;&#x2F;使用JPA注解配置映射关系\n@Entity &#x2F;&#x2F;告诉JPA这是一个实体类（和数据表映射的类）\n@Table(name &#x3D; &quot;tbl_user&quot;) &#x2F;&#x2F;@Table来指定和哪个数据表对应;如果省略默认表名就是user；\npublic class User &#123;\n\n    @Id &#x2F;&#x2F;这是一个主键\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)&#x2F;&#x2F;自增主键\n    private Integer id;\n\n    @Column(name &#x3D; &quot;last_name&quot;,length &#x3D; 50) &#x2F;&#x2F;这是和数据表对应的一个列\n    private String lastName;\n    @Column &#x2F;&#x2F;省略默认列名就是属性名\n    private String email;\n\n2）、编写一个Dao接口来操作实体类对应的数据表（Repository）\n&#x2F;&#x2F;继承JpaRepository来完成对数据库的操作\npublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;\n&#125;\n\n\n3）、基本的配置JpaProperties\nspring:  \n jpa:\n    hibernate:\n#     更新或者创建数据表结构\n      ddl-auto: update\n#    控制台显示SQL\n    show-sql: true\n\n\n\n七、启动配置原理几个重要的事件回调机制\n配置在META-INF&#x2F;spring.factories\nApplicationContextInitializer\nSpringApplicationRunListener\n只需要放在ioc容器中\nApplicationRunner\nCommandLineRunner\n启动流程：\n1、创建SpringApplication对象initialize(sources);\nprivate void initialize(Object[] sources) &#123;\n    &#x2F;&#x2F;保存主配置类\n    if (sources !&#x3D; null &amp;&amp; sources.length &gt; 0) &#123;\n        this.sources.addAll(Arrays.asList(sources));\n    &#125;\n    &#x2F;&#x2F;判断当前是否一个web应用\n    this.webEnvironment &#x3D; deduceWebEnvironment();\n    &#x2F;&#x2F;从类路径下找到META-INF&#x2F;spring.factories配置的所有ApplicationContextInitializer；然后保存起来\n    setInitializers((Collection) getSpringFactoriesInstances(\n        ApplicationContextInitializer.class));\n    &#x2F;&#x2F;从类路径下找到ETA-INF&#x2F;spring.factories配置的所有ApplicationListener\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    &#x2F;&#x2F;从多个配置类中找到有main方法的主配置类\n    this.mainApplicationClass &#x3D; deduceMainApplicationClass();\n&#125;\n\n\n\n2、运行run方法public ConfigurableApplicationContext run(String... args) &#123;\n   StopWatch stopWatch &#x3D; new StopWatch();\n   stopWatch.start();\n   ConfigurableApplicationContext context &#x3D; null;\n   FailureAnalyzers analyzers &#x3D; null;\n   configureHeadlessProperty();\n    \n   &#x2F;&#x2F;获取SpringApplicationRunListeners；从类路径下META-INF&#x2F;spring.factories\n   SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);\n    &#x2F;&#x2F;回调所有的获取SpringApplicationRunListener.starting()方法\n   listeners.starting();\n   try &#123;\n       &#x2F;&#x2F;封装命令行参数\n      ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(\n            args);\n      &#x2F;&#x2F;准备环境\n      ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,\n            applicationArguments);\n       \t\t&#x2F;&#x2F;创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成\n       \n      Banner printedBanner &#x3D; printBanner(environment);\n       \n       &#x2F;&#x2F;创建ApplicationContext；决定创建web的ioc还是普通的ioc\n      context &#x3D; createApplicationContext();\n       \n      analyzers &#x3D; new FailureAnalyzers(context);\n       &#x2F;&#x2F;准备上下文环境;将environment保存到ioc中；而且applyInitializers()；\n       &#x2F;&#x2F;applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法\n       &#x2F;&#x2F;回调所有的SpringApplicationRunListener的contextPrepared()；\n       &#x2F;&#x2F;\n      prepareContext(context, environment, listeners, applicationArguments,\n            printedBanner);\n       &#x2F;&#x2F;prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；\n       \n       &#x2F;&#x2F;s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版\n       &#x2F;&#x2F;扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）\n      refreshContext(context);\n       &#x2F;&#x2F;从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调\n       &#x2F;&#x2F;ApplicationRunner先回调，CommandLineRunner再回调\n      afterRefresh(context, applicationArguments);\n       &#x2F;&#x2F;所有的SpringApplicationRunListener回调finished方法\n      listeners.finished(context, null);\n      stopWatch.stop();\n      if (this.logStartupInfo) &#123;\n         new StartupInfoLogger(this.mainApplicationClass)\n               .logStarted(getApplicationLog(), stopWatch);\n      &#125;\n       &#x2F;&#x2F;整个SpringBoot应用启动完成以后返回启动的ioc容器；\n      return context;\n   &#125;\n   catch (Throwable ex) &#123;\n      handleRunFailure(context, listeners, analyzers, ex);\n      throw new IllegalStateException(ex);\n   &#125;\n&#125;\n\n3、事件监听机制配置在META-INF&#x2F;spring.factories\nApplicationContextInitializer\npublic class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123;\n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) &#123;\n        System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+applicationContext);\n    &#125;\n&#125;\n\n\nSpringApplicationRunListener\npublic class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123;\n\n    &#x2F;&#x2F;必须有的构造器\n    public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123;\n\n    &#125;\n\n    @Override\n    public void starting() &#123;\n        System.out.println(&quot;SpringApplicationRunListener...starting...&quot;);\n    &#125;\n\n    @Override\n    public void environmentPrepared(ConfigurableEnvironment environment) &#123;\n        Object o &#x3D; environment.getSystemProperties().get(&quot;os.name&quot;);\n        System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o);\n    &#125;\n\n    @Override\n    public void contextPrepared(ConfigurableApplicationContext context) &#123;\n        System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;);\n    &#125;\n\n    @Override\n    public void contextLoaded(ConfigurableApplicationContext context) &#123;\n        System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;);\n    &#125;\n\n    @Override\n    public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;\n        System.out.println(&quot;SpringApplicationRunListener...finished...&quot;);\n    &#125;\n&#125;\n\n\n配置（META-INF&#x2F;spring.factories）\norg.springframework.context.ApplicationContextInitializer&#x3D;\\\ncom.atguigu.springboot.listener.HelloApplicationContextInitializer\n\norg.springframework.boot.SpringApplicationRunListener&#x3D;\\\ncom.atguigu.springboot.listener.HelloSpringApplicationRunListener\n\n\n\n\n\n只需要放在ioc容器中\nApplicationRunner\n@Component\npublic class HelloApplicationRunner implements ApplicationRunner &#123;\n    @Override\n    public void run(ApplicationArguments args) throws Exception &#123;\n        System.out.println(&quot;ApplicationRunner...run....&quot;);\n    &#125;\n&#125;\n\n\n\nCommandLineRunner\n@Component\npublic class HelloCommandLineRunner implements CommandLineRunner &#123;\n    @Override\n    public void run(String... args) throws Exception &#123;\n        System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args));\n    &#125;\n&#125;\n\n\n\n八、自定义starterstarter：\n​\t1、这个场景需要使用到的依赖是什么？\n​\t2、如何编写自动配置\n@Configuration  &#x2F;&#x2F;指定这个类是一个配置类\n@ConditionalOnXXX  &#x2F;&#x2F;在指定条件成立的情况下自动配置类生效\n@AutoConfigureAfter  &#x2F;&#x2F;指定自动配置类的顺序\n@Bean  &#x2F;&#x2F;给容器中添加组件\n\n@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置\n@EnableConfigurationProperties &#x2F;&#x2F;让xxxProperties生效加入到容器中\n\n自动配置类要能加载\n将需要启动就加载的自动配置类，配置在META-INF&#x2F;spring.factories\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\n\n​\t3、模式：\n启动器只用来做依赖导入；\n专门来写一个自动配置模块；\n启动器依赖自动配置；别人只需要引入启动器（starter）\nmybatis-spring-boot-starter；自定义启动器名-spring-boot-starter\n步骤：\n1）、启动器模块\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;groupId&gt;com.atguigu.starter&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;atguigu-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;!--启动器--&gt;\n    &lt;dependencies&gt;\n\n        &lt;!--引入自动配置模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.starter&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n&lt;&#x2F;project&gt;\n\n2）、自动配置模块\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n   &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n   &lt;groupId&gt;com.atguigu.starter&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;&#x2F;artifactId&gt;\n   &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n   &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;\n\n   &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;&#x2F;name&gt;\n   &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;\n\n   &lt;parent&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;1.5.10.RELEASE&lt;&#x2F;version&gt;\n      &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n   &lt;&#x2F;parent&gt;\n\n   &lt;properties&gt;\n      &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;\n      &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n   &lt;&#x2F;properties&gt;\n\n   &lt;dependencies&gt;\n\n      &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;\n      &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n         &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n      &lt;&#x2F;dependency&gt;\n\n   &lt;&#x2F;dependencies&gt;\n\n\n\n&lt;&#x2F;project&gt;\n\n\n\n\npackage com.atguigu.starter;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix &#x3D; &quot;atguigu.hello&quot;)\npublic class HelloProperties &#123;\n\n    private String prefix;\n    private String suffix;\n\n    public String getPrefix() &#123;\n        return prefix;\n    &#125;\n\n    public void setPrefix(String prefix) &#123;\n        this.prefix &#x3D; prefix;\n    &#125;\n\n    public String getSuffix() &#123;\n        return suffix;\n    &#125;\n\n    public void setSuffix(String suffix) &#123;\n        this.suffix &#x3D; suffix;\n    &#125;\n&#125;\n\n\npackage com.atguigu.starter;\n\npublic class HelloService &#123;\n\n    HelloProperties helloProperties;\n\n    public HelloProperties getHelloProperties() &#123;\n        return helloProperties;\n    &#125;\n\n    public void setHelloProperties(HelloProperties helloProperties) &#123;\n        this.helloProperties &#x3D; helloProperties;\n    &#125;\n\n    public String sayHellAtguigu(String name)&#123;\n        return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix();\n    &#125;\n&#125;\n\n\npackage com.atguigu.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConditionalOnWebApplication &#x2F;&#x2F;web应用才生效\n@EnableConfigurationProperties(HelloProperties.class)\npublic class HelloServiceAutoConfiguration &#123;\n\n    @Autowired\n    HelloProperties helloProperties;\n    @Bean\n    public HelloService helloService()&#123;\n        HelloService service &#x3D; new HelloService();\n        service.setHelloProperties(helloProperties);\n        return service;\n    &#125;\n&#125;\n\n\n更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples\n","slug":"springboot","date":"2019-01-10T11:38:48.000Z","categories_index":"java","tags_index":"Spring","author_index":"云の博客"}]